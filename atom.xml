<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>〇</title>
  
  <subtitle>世界的本质即是无限的循环</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-10-06T13:19:15.297Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>rootReturn0</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Soul-like</title>
    <link href="http://yoursite.com/2019/10/06/soul-like/"/>
    <id>http://yoursite.com/2019/10/06/soul-like/</id>
    <published>2019-10-05T16:24:23.000Z</published>
    <updated>2019-10-06T13:19:15.297Z</updated>
    
    <content type="html"><![CDATA[<script src="https://ajax.aspnetcdn.com/ajax/jQuery/jquery-3.4.1.min.js"></script><div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="请输入密码。" />    <label for="pass">请输入密码。</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">U2FsdGVkX1+yUfIHm5WjteGzXDXuEr9PL59qqKSceOlwG0B9yZOhZ8p/lcpWiRheezamvaSEi+PIh6uo7+Xr28EECzsgqXoKJA/xu570lJ6uv6y0rQY4PvQ3uI/YlcriF0QihSCdozHIALftKaIRMk0DfsWGkRvlQZXitjDmSWpxSiGoU+H8iz39kO+WgJ0I51kKx1IoODgs9MfKwckOKnhacsZ3/XkCNXL0dhrKzvZQW6Iiv+D/VKn4ZsWTR5OiaP/XP8DJX9i13nOVKAtuz7CtZjS+U7QXbMFilDIi0UEumqpvQzyxbeWxYYtJ+hrxqFk5HDmrphh//0FMcnkKGtGLoGnKUEKYUSDhPITRO8CACR0K/PVE1nBIlms/XJKZIq/GqMtP5KDpMg1JElUhnojfoEbYEKRLHVZdaI3liVYVk6vTZ11T3ynXYCDvDX05bXZFzaQJxCw0NV9HJcrJWlg4vO4Q8vWDYfImBHW2dOdYMsQP6n54EKu1tLjobHlxFWXqlwUnxblXfwLo7RvmwVWFl89UfRUkRSvgZUjifBExbl9cetmzgUF+VS61dhvEQlyy+qIRmy9emA87JuRhNL01KuBzrAjwgzowIbCOF4YmkHbKnmk+QJleoLdvM7CBKQqQADmPR5XnppMd7Lm4XgQ7MlrP3IP5qhhNpPebg6eGXy/qkhbt7Ozaud+VqdT6</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      Ashen one
    
    </summary>
    
    
      <category term="随笔" scheme="http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>xv6-调度</title>
    <link href="http://yoursite.com/2019/08/31/xv6-%E8%B0%83%E5%BA%A6/"/>
    <id>http://yoursite.com/2019/08/31/xv6-调度/</id>
    <published>2019-08-31T10:50:22.000Z</published>
    <updated>2019-08-31T13:32:59.676Z</updated>
    
    <content type="html"><![CDATA[<h2>调度</h2><p>由于可能同时有多个CPU请求进行调度，故需要进程表锁<code>ptable.lock</code>来避免竞争。</p><p>因此，进程在让出CPU前，必须要获得进程表锁，并释放其拥有的其他锁（避免同时持有多个锁导致死锁），修改自己的状态<code>proc-&gt;state</code>，然后进行调度。</p><h3>函数</h3><p>以下函数位于代码文件<code>proc.c</code>中。</p><h4>sched</h4><p>进程进入调度器，且必须持有进程表锁并改变进程状态。由于进程此时持有进程表锁，所以CPU应该是在关中断的情况下运行。</p><p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">sched(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> intena;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> = <span class="title">myproc</span>();</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 未持有进程表锁，不应进入调度，引发内核错误</span></span><br><span class="line">  <span class="keyword">if</span>(!holding(&amp;ptable.lock))</span><br><span class="line">    panic(<span class="string">"sched ptable.lock"</span>);</span><br><span class="line">  <span class="comment">// 处于锁状态，不应进入调度，引发内核错误</span></span><br><span class="line">  <span class="keyword">if</span>(mycpu()-&gt;ncli != <span class="number">1</span>)</span><br><span class="line">    panic(<span class="string">"sched locks"</span>);</span><br><span class="line">  <span class="comment">// 进程处于运行态，不应进入调度，引发内核错误</span></span><br><span class="line">  <span class="keyword">if</span>(p-&gt;state == RUNNING)</span><br><span class="line">    panic(<span class="string">"sched running"</span>);</span><br><span class="line">  <span class="comment">// 开中断，不可执行mycpu()函数，不应进入调度，引发内核错误</span></span><br><span class="line">  <span class="keyword">if</span>(readeflags()&amp;FL_IF)</span><br><span class="line">    panic(<span class="string">"sched interruptible"</span>);</span><br><span class="line">  intena = mycpu()-&gt;intena; <span class="comment">// 暂存状态</span></span><br><span class="line">  swtch(&amp;p-&gt;context, mycpu()-&gt;scheduler); <span class="comment">// 保存当前上下文，并切换到之前保存的调度器的上下文，进入调度器</span></span><br><span class="line">  mycpu()-&gt;intena = intena; <span class="comment">// 恢复状态</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4>yield</h4><p>在xv6中，使用时间片轮转法进行调度。当进程用完它的CPU时间片时，时钟中断会调用<code>yield</code>函数来让出CPU给新的进程，<code>yield</code>调用<code>sched</code>函数，<code>sched</code>调用<code>swtch</code>来切换都调度器线程：</p><p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">yield(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  acquire(&amp;ptable.lock);  <span class="comment">//DOC: yieldlock 请求进程表锁</span></span><br><span class="line">  myproc()-&gt;state = RUNNABLE; <span class="comment">// 切换进程状态</span></span><br><span class="line">  sched(); </span><br><span class="line">  release(&amp;ptable.lock); <span class="comment">// 释放进程表锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4>scheduler</h4><p>每个CPU在设置完成自己之后调用<code>scheduler</code>。</p><p>调度器<code>scheduler</code>永远不会返回，而是不断循环。循环步骤为：</p><ol><li>选择要运行的流程</li><li>swtch开始运行该过程</li><li>最终该过程通过swtch将控制转移回调度程序。</li></ol><p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">scheduler(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> *<span class="title">c</span> = <span class="title">mycpu</span>();</span></span><br><span class="line">  c-&gt;proc = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 不断循环，永不停止</span></span><br><span class="line">  <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    <span class="comment">// 开中断，以允许I/O到达</span></span><br><span class="line">    sti();  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在进程表上不断循环，寻找进程并运行</span></span><br><span class="line">    acquire(&amp;ptable.lock); <span class="comment">// 请求进程表锁</span></span><br><span class="line">    <span class="keyword">for</span>(p = ptable.proc; p &lt; &amp;ptable.proc[NPROC]; p++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(p-&gt;state != RUNNABLE) <span class="comment">// 进程不可运行，转到下一个进程</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Switch to chosen process.  It is the process's job</span></span><br><span class="line">      <span class="comment">// to release ptable.lock and then reacquire it</span></span><br><span class="line">      <span class="comment">// before jumping back to us.</span></span><br><span class="line">      <span class="comment">// 切换到选定的进程</span></span><br><span class="line">      c-&gt;proc = p;</span><br><span class="line">      switchuvm(p); <span class="comment">// 切换到该进程的页表</span></span><br><span class="line">      p-&gt;state = RUNNING;</span><br><span class="line"></span><br><span class="line">      swtch(&amp;(c-&gt;scheduler), p-&gt;context); <span class="comment">// 切换到该进程运行</span></span><br><span class="line">      switchkvm(); <span class="comment">// 当没有进程正在运行时，将页表寄存器切换到仅内核页表。</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// Process is done running for now.</span></span><br><span class="line">      <span class="comment">// It should have changed its p-&gt;state before coming back.</span></span><br><span class="line">      <span class="comment">// 进程已结束运行，改变自身状态</span></span><br><span class="line">      c-&gt;proc = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    release(&amp;ptable.lock); <span class="comment">// 释放进程表锁，防止其他CPU无法进行调度</span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3>锁与中断</h3><h4>锁</h4><ul><li>为保证进程状态的上下文在运行<code>swtch</code>时保持不变：进程表锁由旧进程获得，新进程释放。</li><li>为防止其他CPU闲置时锁被当前CPU占有而无法调度，其他CPU上运行进程无法让出CPU，导致死锁的情况：在遍历一次进程表后总要释放锁。</li></ul><h4>中断</h4><ul><li>为防止所有进程都在等待I/O时关中断导致的I/O无法到达引发的死锁，调度器在每次循坏开始前进行开中断。</li></ul><h2>睡眠与唤醒</h2><p>函数<code>sleep</code>和<code>wakeup</code>位于代码文件<code>proc.c</code>中。</p><p>使进程进入睡眠或进行唤醒均需要改变进程状态，故需要进程表锁以保证状态修改的原子性。其中函数<code>sleep</code>要在使进程进入睡眠前获取进程表锁，以保证在使函数进入睡眠时至少持有一个锁，防止<code>wakeup</code>在进程进入睡眠前被调用导致的死锁。当<code>sleep</code>本身持有的锁为进程表锁时，则略过请求这一步，防止死锁。</p><h2>可改进之处</h2><h3>调度</h3><ul><li>轮转法无优先级的区分</li></ul><p>会导致高优先级的进程无法优先运行，可能导致系统运行时间的增加，影响使用者在实际使用时的体验。可使用其他较为复杂的算法，如高响应比优先算法等以改进体验。</p><h3>睡眠与唤醒</h3><ul><li>唤醒需要遍历进程表</li></ul><p>在进程数量大的时候这种做法效率极低。使用另一个结构体来维护链表可大大提高效率。</p><ul><li>唤醒时会唤醒队列中全部进程</li></ul><p>大多数情况下，同一时间需要唤醒的进程在队列中是少数部分，许多仍需等待的进程将会被“莫名其妙”地唤醒并再度检查状态重新进入睡眠，导致操作系统需要处理许多新的不必要的任务。</p><p>唤醒时应分为个体唤醒（唤醒单个进程）和群体唤醒（唤醒所有进程），减少系统负担。</p>]]></content>
    
    <summary type="html">
    
      xv6操作系统之调度源码阅读与分析
    
    </summary>
    
    
      <category term="学习" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>xv6-管道</title>
    <link href="http://yoursite.com/2019/08/31/xv6-%E7%AE%A1%E9%81%93/"/>
    <id>http://yoursite.com/2019/08/31/xv6-管道/</id>
    <published>2019-08-31T00:29:38.000Z</published>
    <updated>2019-08-31T16:07:10.652Z</updated>
    
    <content type="html"><![CDATA[<h2>管道</h2><p>从管道的一端写入数据字节，然后数据被拷贝到内核缓冲区中，接着进程就能从管道的另一端读取数据了。</p><p>在xv6中，管道使用被读取字节数<code>nread</code>和被写入字节数<code>nwrite</code>的差值判断管道状态：</p><ul><li>nwrite == nread 则数据未写入或被读取完毕，管道空</li><li>nwrite == nread + PIPESIZE 则管道满</li></ul><p>由于管道的读取与写入均需要使用<code>nread</code>和<code>nwrite</code>以获悉管道状态，故这两个计数参数不能在某一函数（写入/读取）清零，否则将影响另一函数（读取/写入）的执行。因此，xv6中使用<code>data[nread % PIPESIZE]</code>和<code>data[nwrite % PIPESIZE]</code>来控制读写时的管道数据偏移，即循环写/读，在<code>data[PIPESIZE-1]</code>后写入的数据存放在<code>data[0]</code>中。</p><h3>数据结构</h3><p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span> <span class="comment">// 锁</span></span><br><span class="line">  <span class="keyword">char</span> data[PIPESIZE]; <span class="comment">// 管道数据</span></span><br><span class="line">  uint nread;     <span class="comment">// 被读取字节数，从缓冲区中读取</span></span><br><span class="line">  uint nwrite;    <span class="comment">// 被写入字节数，写入缓冲区</span></span><br><span class="line">  <span class="keyword">int</span> readopen;   <span class="comment">// 读文件描述符是否依旧处于open状态</span></span><br><span class="line">  <span class="keyword">int</span> writeopen;  <span class="comment">// 写文件描述符是否依旧处于open状态</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3>管道函数</h3><p>以下分析管道读写函数，其他函数仅列出函数作用，详细注释见代码文件<code>pipe.c</code>。</p><h4>读写</h4><p>管道读写操作通过管道锁实现互斥，操作运行时必须持有管道锁。</p><p>管道数据写入时首先获取管道锁而后写入数据，若达到管道容量上限，则写操作唤醒读操作后进入睡眠等待并释放管道锁。此时读操作可获得请求的管道锁，在读取完数据后管道变空，则读操作唤醒写操作后进入睡眠等待并释放管道锁。而后管道写操作再次获得管道锁，循环往复直至数据传输完毕，其中最后一次传输可能未写满管道。</p><p>当使用管道的操作被杀后，管道读写操作都将终止；当管道不可读时，管道写操作将被终止。</p><p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 管道写</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">pipewrite(struct pipe *p, <span class="keyword">char</span> *addr, <span class="keyword">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">  acquire(&amp;p-&gt;lock); <span class="comment">// 请求获得管道锁，以保护计数器、数据以及相关不变量</span></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;nwrite == p-&gt;nread + PIPESIZE)&#123;  <span class="comment">// 管道满</span></span><br><span class="line">      <span class="comment">// 如果管道文件不可读或进程被杀，释放管道锁并终止管道写操作</span></span><br><span class="line">      <span class="keyword">if</span>(p-&gt;readopen == <span class="number">0</span> || myproc()-&gt;killed)&#123;</span><br><span class="line">        release(&amp;p-&gt;lock);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      wakeup(&amp;p-&gt;nread); <span class="comment">// 通知睡眠中的读者缓冲区中有数据可读</span></span><br><span class="line">      sleep(&amp;p-&gt;nwrite, &amp;p-&gt;lock);  <span class="comment">// 管道写操作进入睡眠等待（睡眠时将释放管道锁）</span></span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;data[p-&gt;nwrite++ % PIPESIZE] = addr[i]; <span class="comment">// 将所需读取的块内数据赋值给管道数据</span></span><br><span class="line">  &#125;</span><br><span class="line">  wakeup(&amp;p-&gt;nread);  <span class="comment">// 通知睡眠中的读者缓冲区中有数据可读</span></span><br><span class="line">  release(&amp;p-&gt;lock); <span class="comment">// 释放管道锁</span></span><br><span class="line">  <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//管道读</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">piperead(struct pipe *p, <span class="keyword">char</span> *addr, <span class="keyword">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">  acquire(&amp;p-&gt;lock); <span class="comment">// 请求获得管道锁，以保护计数器、数据以及相关不变量</span></span><br><span class="line">  <span class="keyword">while</span>(p-&gt;nread == p-&gt;nwrite &amp;&amp; p-&gt;writeopen)&#123;  <span class="comment">//DOC: 管道为空且管道可写，则管道读操作可进入睡眠</span></span><br><span class="line">    <span class="comment">// 进程被杀，释放管道锁，终止管道读操作</span></span><br><span class="line">    <span class="keyword">if</span>(myproc()-&gt;killed)&#123;</span><br><span class="line">      release(&amp;p-&gt;lock);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sleep(&amp;p-&gt;nread, &amp;p-&gt;lock); <span class="comment">//DOC: piperead-sleep 管道读操作进入睡眠等待（睡眠时将释放管道锁）</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)&#123;  <span class="comment">// 拷贝数据</span></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;nread == p-&gt;nwrite) <span class="comment">// 读取字节数等于写入字节数，表示读取完成</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    addr[i] = p-&gt;data[p-&gt;nread++ % PIPESIZE]; <span class="comment">// 将所需读取的管道数据赋值给块内数据</span></span><br><span class="line">  &#125;</span><br><span class="line">  wakeup(&amp;p-&gt;nwrite);  <span class="comment">// 通知睡眠中的写者缓冲区中可写</span></span><br><span class="line">  release(&amp;p-&gt;lock);</span><br><span class="line">  <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4>其他</h4><ul><li>pipealloc 管道分配，并初始化管道。</li><li>pipeclose 管道关闭。若读写两方均关闭，则释放内存；否则关闭管道一端并唤醒另一方。当关闭写端时，仍可进行读操作，但将管道内剩余数据读完后，再次进行读操作便返回0，相当于读到文件末尾；当关闭读段时，写操作会在进行过程中中断。</li></ul>]]></content>
    
    <summary type="html">
    
      xv6操作系统之管道源码阅读与分析
    
    </summary>
    
    
      <category term="学习" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>xv6-文件系统</title>
    <link href="http://yoursite.com/2019/08/31/xv6-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    <id>http://yoursite.com/2019/08/31/xv6-文件系统/</id>
    <published>2019-08-30T17:47:50.000Z</published>
    <updated>2019-08-31T00:26:38.022Z</updated>
    
    <content type="html"><![CDATA[<h2>文件系统总体设计</h2><h3>文件系统分层</h3><p><img src="https://th0ar.gitbooks.io/xv6-chinese/content/pic/f6-1.png" alt="文件系统层"></p><p>如图所示xv6的文件系统分6层实现：</p><ol><li>第一层（自下而上）通过块缓冲读写 IDE 硬盘，同步对磁盘的访问，且通过块的锁保证同一时间只有一个内核进程可以修改磁盘块；</li><li>第二层使得更高层的接口可以将对磁盘的更新按会话打包，通过会话的方式来保证这些操作是原子操作。</li><li>第三层提供无名文件，每一个文件由一个inode和一连串的数据块组成。</li><li>第四层将目录实现为一种特殊的inode，内容是一连串的目录项，每一个目录项包含一个文件名和对应的inode。</li><li>第五层提供了层次路经名（如/xx/xxx），这一层通过递归的方式来查询路径对应的文件。</li><li>第六层将许多资源（如管道，设备，文件等）抽象为文件系统的接口，极大地简化了程序员的工作。</li></ol><h3>磁盘分层</h3><p>磁盘分层为引导块、超级块、日志块、inode块、空闲块位图和数据块等。</p><p>文件系统不使用引导块；超级块包含了文件系统的元信息；日志块中的日志维护了文件系统操作的原子性，防止操作过程中引发的系统崩溃而导致的数据不同步；inode块用于存放inode（一个块可存放多个inode）；空闲块位图便于查找空闲的块；数据块中保存了文件和目录等内容。</p><h2>块缓冲层</h2><h3>需要实现的目标</h3><ol><li>同步对磁盘的访问。对于任意一个块，同一时间仅有一份拷贝放在内存中且只允许一个内核线程对该拷贝进行修改。</li><li>缓存常用的块以减少磁盘读取次数，提高系统效率。</li></ol><h3>实现方案</h3><p>代码参见<code>bio.c</code>。</p><p>根据时间与空间局部性原理，将最近经常访问的磁盘块缓存在内存中，并使用LRU替换策略。</p><h4>结构定义</h4><p>xv6将缓冲区分为两种状态：</p><ol><li>B_VALID 意味着这个缓冲区拥有磁盘块的有效内容；</li><li>B_DIRTY 意味着缓冲区的内容已经被改变并且需要写回磁盘；</li></ol><p>与旧版相比，B_BUSY 状态在最新版代码中被删去。但由于缓存区中的块的锁的存在，只有持有锁才能访问该块，而在另一线程未使用完成前，该锁不会被释放，此时只能循环等待锁的释放，获得锁后方可获得块。故依旧可保持块内容的原子性。</p><p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 内存中的磁盘块结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buf</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> flags; <span class="comment">// 标记磁盘状态，valid/dirty</span></span><br><span class="line">  uint dev; <span class="comment">// 磁盘设备号</span></span><br><span class="line">  uint blockno; <span class="comment">// 块编号</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sleeplock</span> <span class="title">lock</span>;</span></span><br><span class="line">  uint refcnt; <span class="comment">// 引用计数</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">prev</span>;</span> <span class="comment">// LRU cache list 使用LRU替换</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">next</span>;</span> <span class="comment">// 链式结构连接磁盘块</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">qnext</span>;</span> <span class="comment">// 磁盘队列</span></span><br><span class="line">  uchar data[BSIZE]; <span class="comment">// 块大小为512字节</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 块缓冲区结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> <span class="title">buf</span>[<span class="title">NBUF</span>];</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通过 prev/next 连接所有缓冲块</span></span><br><span class="line">  <span class="comment">// 其中 head.next 是最近最常使用的块.</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> <span class="title">head</span>;</span></span><br><span class="line">&#125; bcache;</span><br></pre></td></tr></table></figure></p><h4>初始化 binit</h4><p>从一个静态数组<code>buf</code>中构建出一个有<code>NBUF</code>个元素的双向链表。所有对块缓冲的访问都通过链表而非静态数组。</p><p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">binit(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">b</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化块缓冲锁</span></span><br><span class="line">  initlock(&amp;bcache.lock, <span class="string">"bcache"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//PAGEBREAK!</span></span><br><span class="line">  <span class="comment">// 构建缓冲双向链表</span></span><br><span class="line">  bcache.head.prev = &amp;bcache.head;</span><br><span class="line">  bcache.head.next = &amp;bcache.head;</span><br><span class="line">  <span class="keyword">for</span>(b = bcache.buf; b &lt; bcache.buf+NBUF; b++)&#123;</span><br><span class="line">    b-&gt;next = bcache.head.next;</span><br><span class="line">    b-&gt;prev = &amp;bcache.head;</span><br><span class="line">    <span class="comment">// 初始化缓冲区中的块的锁</span></span><br><span class="line">    initsleeplock(&amp;b-&gt;lock, <span class="string">"buffer"</span>);</span><br><span class="line">    bcache.head.next-&gt;prev = b;</span><br><span class="line">    bcache.head.next = b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4>查找 bget</h4><p>扫描缓冲区链表，通过给定的设备号和扇区号找到对应的缓冲区。如果未找到，则分配一个缓冲区，否则返回一个持有锁的缓冲区。代码中在双向链表的搜索中向最近最常使用方向查找，若未找到则向另一方向查找空闲缓冲区以分配。</p><p>其中若找到缓冲区中指定的块，返回的结果也不一定是指定的块。因为在请求该块的锁前已释放缓冲区锁，若该块未持有锁且正在被用来缓冲另外一个块，则重新获得锁时已是另一个块。</p><p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">buf</span>*</span></span><br><span class="line"><span class="class"><span class="title">bget</span>(<span class="title">uint</span> <span class="title">dev</span>, <span class="title">uint</span> <span class="title">blockno</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">b</span>;</span></span><br><span class="line"></span><br><span class="line">  acquire(&amp;bcache.lock); <span class="comment">// 请求块缓冲区锁</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 不能保证 b 仍然是可用的缓冲区：它有可能被用来缓冲另外一个块。</span></span><br><span class="line">  <span class="keyword">for</span>(b = bcache.head.next; b != &amp;bcache.head; b = b-&gt;next)&#123;</span><br><span class="line">    <span class="keyword">if</span>(b-&gt;dev == dev &amp;&amp; b-&gt;blockno == blockno)&#123;</span><br><span class="line">      b-&gt;refcnt++; <span class="comment">// 引用计数加一</span></span><br><span class="line">      release(&amp;bcache.lock); <span class="comment">// 释放块缓冲区锁</span></span><br><span class="line">      acquiresleep(&amp;b-&gt;lock); <span class="comment">// 请求该块的锁</span></span><br><span class="line">      <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Not cached; recycle an unused buffer. 未找到则重新查找</span></span><br><span class="line">  <span class="comment">// Even if refcnt==0, B_DIRTY indicates a buffer is in use</span></span><br><span class="line">  <span class="comment">// because log.c has modified it but not yet committed it.</span></span><br><span class="line">  <span class="comment">// 即使refcnt等于0，也可通过B_DIRTY知道缓冲区被使用，此时日志已修改但未提交 </span></span><br><span class="line">  <span class="keyword">for</span>(b = bcache.head.prev; b != &amp;bcache.head; b = b-&gt;prev)&#123;</span><br><span class="line">    <span class="keyword">if</span>(b-&gt;refcnt == <span class="number">0</span> &amp;&amp; (b-&gt;flags &amp; B_DIRTY) == <span class="number">0</span>) &#123;</span><br><span class="line">      b-&gt;dev = dev;</span><br><span class="line">      b-&gt;blockno = blockno;</span><br><span class="line">      b-&gt;flags = <span class="number">0</span>;</span><br><span class="line">      b-&gt;refcnt = <span class="number">1</span>;</span><br><span class="line">      release(&amp;bcache.lock);</span><br><span class="line">      acquiresleep(&amp;b-&gt;lock);</span><br><span class="line">      <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 未找到块且未能分配块，引发内核错误</span></span><br><span class="line">  panic(<span class="string">"bget: no buffers"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4>读 bread</h4><p><code>bread</code>会首先调用<code>bget</code>从缓存中去寻找块是否存在。如果存在直接返回；如果不存在则请求磁盘读操作，读到缓存中后再返回结果。</p><p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buf</span>*</span></span><br><span class="line"><span class="class"><span class="title">bread</span>(<span class="title">uint</span> <span class="title">dev</span>, <span class="title">uint</span> <span class="title">blockno</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">b</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取缓冲区</span></span><br><span class="line">  b = bget(dev, blockno);</span><br><span class="line">  <span class="comment">// 如果缓冲区中不存在指定的块，则从磁盘中读出</span></span><br><span class="line">  <span class="keyword">if</span>((b-&gt;flags &amp; B_VALID) == <span class="number">0</span>) &#123;</span><br><span class="line">    iderw(b);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4>写 bwrite</h4><p>设置 B_DIRTY 位并且调用 iderw 将缓冲区的内容写到磁盘。</p><p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">bwrite(struct buf *b)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 该块未锁，可能已被释放，无法写入，引发内核错误</span></span><br><span class="line">  <span class="keyword">if</span>(!holdingsleep(&amp;b-&gt;lock))</span><br><span class="line">    panic(<span class="string">"bwrite"</span>);</span><br><span class="line">  b-&gt;flags |= B_DIRTY;</span><br><span class="line">  iderw(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4>释放 brelse</h4><p>将一块缓冲区移动到链表的头部，唤醒睡眠在这块缓冲区上的进程。</p><p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 唤醒睡眠在这块缓冲区上的进程；将一块缓冲区移动到链表的头部。</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">brelse(struct buf *b)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 缓冲区未持有块锁，引发内核错误</span></span><br><span class="line">  <span class="keyword">if</span>(!holdingsleep(&amp;b-&gt;lock))</span><br><span class="line">    panic(<span class="string">"brelse"</span>);</span><br><span class="line"></span><br><span class="line">  releasesleep(&amp;b-&gt;lock); <span class="comment">// 释放块锁</span></span><br><span class="line"></span><br><span class="line">  acquire(&amp;bcache.lock); <span class="comment">// 请求  缓冲区锁</span></span><br><span class="line">  b-&gt;refcnt--; <span class="comment">//引用计数减一</span></span><br><span class="line">  <span class="keyword">if</span> (b-&gt;refcnt == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 无进程等待使用，移动到链表头部</span></span><br><span class="line">    b-&gt;next-&gt;prev = b-&gt;prev;</span><br><span class="line">    b-&gt;prev-&gt;next = b-&gt;next;</span><br><span class="line">    b-&gt;next = bcache.head.next;</span><br><span class="line">    b-&gt;prev = &amp;bcache.head;</span><br><span class="line">    bcache.head.next-&gt;prev = b;</span><br><span class="line">    bcache.head.next = b;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  release(&amp;bcache.lock); <span class="comment">//释放缓冲区锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3>日志层</h3><p>每一个系统调用都可能包含一个必须从头到尾原子完成的写操作序列，称这样的一个序列为一个会话。任何时候只能有一个进程在一个会话之中，其他进程必须等待当前会话中的进程结束。因此同一时刻日志最多只记录一次会话。</p><p>该层用于维护系统崩溃后到原子性，即会话要么完成，要么系统恢复至会话开始前的状态。</p><h3>块分配器</h3><p>本部分涉及的函数位于<code>fs.c</code>。</p><p>由于<code>bread</code>与<code>brelse</code>已有锁进行互斥，块分配器无需再加锁。</p><h4>分配新的磁盘块</h4><p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> uint</span><br><span class="line">balloc(uint dev)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> b, bi, m;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp</span>;</span></span><br><span class="line"></span><br><span class="line">  bp = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(b = <span class="number">0</span>; b &lt; sb.size; b += BPB)&#123; <span class="comment">// 读位图每一块</span></span><br><span class="line">    bp = bread(dev, BBLOCK(b, sb));</span><br><span class="line">    <span class="keyword">for</span>(bi = <span class="number">0</span>; bi &lt; BPB &amp;&amp; b + bi &lt; sb.size; bi++)&#123; <span class="comment">// 读块内每一位</span></span><br><span class="line">      m = <span class="number">1</span> &lt;&lt; (bi % <span class="number">8</span>);</span><br><span class="line">      <span class="keyword">if</span>((bp-&gt;data[bi/<span class="number">8</span>] &amp; m) == <span class="number">0</span>)&#123;  <span class="comment">// 判断块是否空闲</span></span><br><span class="line">        bp-&gt;data[bi/<span class="number">8</span>] |= m;  <span class="comment">// 将块标记为使用中</span></span><br><span class="line">        log_write(bp);</span><br><span class="line">        brelse(bp); <span class="comment">// 释放块</span></span><br><span class="line">        bzero(dev, b + bi); <span class="comment">// 清零块</span></span><br><span class="line">        <span class="keyword">return</span> b + bi;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    brelse(bp);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 超出块范围，引发错误</span></span><br><span class="line">  panic(<span class="string">"balloc: out of blocks"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4>释放磁盘块</h4><p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">bfree(<span class="keyword">int</span> dev, uint b)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp</span>;</span></span><br><span class="line">  <span class="keyword">int</span> bi, m;</span><br><span class="line"></span><br><span class="line">  readsb(dev, &amp;sb);</span><br><span class="line">  bp = bread(dev, BBLOCK(b, sb));</span><br><span class="line">  bi = b % BPB;</span><br><span class="line">  m = <span class="number">1</span> &lt;&lt; (bi % <span class="number">8</span>);</span><br><span class="line">  <span class="keyword">if</span>((bp-&gt;data[bi/<span class="number">8</span>] &amp; m) == <span class="number">0</span>) <span class="comment">// 释放空闲块，错误</span></span><br><span class="line">    panic(<span class="string">"freeing free block"</span>);</span><br><span class="line">  bp-&gt;data[bi/<span class="number">8</span>] &amp;= ~m;</span><br><span class="line">  log_write(bp);</span><br><span class="line">  brelse(bp); <span class="comment">// 释放块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3>inode</h3><p>inode有两种类别：</p><ul><li><p>磁盘上的记录文件大小、数据块扇区号的数据结构</p><p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dinode</span> &#123;</span></span><br><span class="line">  <span class="keyword">short</span> type;           <span class="comment">// 区分文件、目录和特殊文件的 i 节点，0表示为空闲节点</span></span><br><span class="line">  <span class="keyword">short</span> major;          <span class="comment">// 主设备号（仅限T_DEV）</span></span><br><span class="line">  <span class="keyword">short</span> minor;          <span class="comment">// 辅设备号（仅限T_DEV）</span></span><br><span class="line">  <span class="keyword">short</span> nlink;          <span class="comment">// 文件系统中的i节点连接数</span></span><br><span class="line">  uint size;            <span class="comment">// 文件的字节数</span></span><br><span class="line">  uint addrs[NDIRECT+<span class="number">1</span>]; <span class="comment">// 用于这个文件的数据块的块号</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p></li><li><p>内存中的一个 i 节点，包含一个磁盘上 i 节点的拷贝，以及一些内核需要的附加信息</p><p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> &#123;</span></span><br><span class="line">  uint dev;           <span class="comment">// Device number 设备号</span></span><br><span class="line">  uint inum;          <span class="comment">// Inode number inode号</span></span><br><span class="line">  <span class="keyword">int</span> ref;            <span class="comment">// Reference count 引用数</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sleeplock</span> <span class="title">lock</span>;</span> <span class="comment">// protects everything below here 保护以下所有数据</span></span><br><span class="line">  <span class="keyword">int</span> valid;          <span class="comment">// inode has been read from disk? i节点是否已从磁盘中读取</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 以下均为磁盘上的i节点，即dinode，的拷贝</span></span><br><span class="line">  <span class="keyword">short</span> type;         <span class="comment">// copy of disk inode</span></span><br><span class="line">  <span class="keyword">short</span> major;</span><br><span class="line">  <span class="keyword">short</span> minor;</span><br><span class="line">  <span class="keyword">short</span> nlink;</span><br><span class="line">  uint size;</span><br><span class="line">  uint addrs[NDIRECT+<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p></li></ul><p>xv6中有inode的缓冲区，作用与块缓冲区相似。以下函数分析仅包含进行特殊操作或较为复杂的函数，其余函数仅写出作用和使用条件（如<code>iunlock</code>）。其中函数位于<code>fs.c</code>。</p><h4>获取inode iget</h4><p><code>iget</code>返回的inode的指针将保证这个inode会留在缓存中，不会被删掉且不会被用于缓存另一个文件（即使未读入磁盘dinode内容）。若磁盘内容未读入，则以后在调用<code>ilock</code>时读入。</p><p>其中<code>iget</code>返回的inode的是未被锁的。在目录层的目录查找中，调用者已经对dp上锁，如果在调用<code>iget</code>返回之前尝试去锁上该i节点会有二次锁上dp的可能从而造成死锁。</p><p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">inode</span>*</span></span><br><span class="line"><span class="class"><span class="title">iget</span>(<span class="title">uint</span> <span class="title">dev</span>, <span class="title">uint</span> <span class="title">inum</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">ip</span>, *<span class="title">empty</span>;</span></span><br><span class="line"></span><br><span class="line">  acquire(&amp;icache.lock);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在inode的cache中寻找目标inode</span></span><br><span class="line">  empty = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(ip = &amp;icache.inode[<span class="number">0</span>]; ip &lt; &amp;icache.inode[NINODE]; ip++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(ip-&gt;ref &gt; <span class="number">0</span> &amp;&amp; ip-&gt;dev == dev &amp;&amp; ip-&gt;inum == inum)&#123;</span><br><span class="line">      ip-&gt;ref++;</span><br><span class="line">      release(&amp;icache.lock);</span><br><span class="line">      <span class="keyword">return</span> ip; <span class="comment">// 此时返回的i节点内容不一定已从磁盘读入cache</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(empty == <span class="number">0</span> &amp;&amp; ip-&gt;ref == <span class="number">0</span>)    <span class="comment">// 记录扫描到的第一个空槽</span></span><br><span class="line">      empty = ip;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 保持inode入口，以下未从磁盘读入内容</span></span><br><span class="line">  <span class="keyword">if</span>(empty == <span class="number">0</span>) <span class="comment">// cache中无i节点空闲，出错</span></span><br><span class="line">    panic(<span class="string">"iget: no inodes"</span>);</span><br><span class="line"></span><br><span class="line">  ip = empty;</span><br><span class="line">  ip-&gt;dev = dev;</span><br><span class="line">  ip-&gt;inum = inum;</span><br><span class="line">  ip-&gt;ref = <span class="number">1</span>;</span><br><span class="line">  ip-&gt;valid = <span class="number">0</span>;</span><br><span class="line">  release(&amp;icache.lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ip;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4>分配inode ialloc</h4><p>在设备dev上分配inode：通过给它类型类型将其标记为已分配，返回未锁定但已分配和引用的inode。这里与<code>balloc</code>相似，可参照前文。</p><p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span>*</span></span><br><span class="line"><span class="class"><span class="title">ialloc</span>(<span class="title">uint</span> <span class="title">dev</span>, <span class="title">short</span> <span class="title">type</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">int</span> inum;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dinode</span> *<span class="title">dip</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(inum = <span class="number">1</span>; inum &lt; sb.ninodes; inum++)&#123;</span><br><span class="line">    bp = bread(dev, IBLOCK(inum, sb));</span><br><span class="line">    dip = (struct dinode*)bp-&gt;data + inum%IPB;</span><br><span class="line">    <span class="keyword">if</span>(dip-&gt;type == <span class="number">0</span>)&#123;  <span class="comment">// inode未分配</span></span><br><span class="line">      <span class="built_in">memset</span>(dip, <span class="number">0</span>, <span class="keyword">sizeof</span>(*dip)); <span class="comment">// 分配空间</span></span><br><span class="line">      dip-&gt;type = type;</span><br><span class="line">      log_write(bp);</span><br><span class="line">      brelse(bp);</span><br><span class="line">      <span class="keyword">return</span> iget(dev, inum);</span><br><span class="line">    &#125;</span><br><span class="line">    brelse(bp);</span><br><span class="line">  &#125;</span><br><span class="line">  panic(<span class="string">"ialloc: no inodes"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4>锁inode ilock</h4><p>锁定给定的inode。如有必要，从磁盘读取inode。</p><p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">ilock(struct inode *ip)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dinode</span> *<span class="title">dip</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(ip == <span class="number">0</span> || ip-&gt;ref &lt; <span class="number">1</span>)</span><br><span class="line">    panic(<span class="string">"ilock"</span>);</span><br><span class="line"></span><br><span class="line">  acquiresleep(&amp;ip-&gt;lock); <span class="comment">// 请求inode锁</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(ip-&gt;valid == <span class="number">0</span>)&#123; <span class="comment">// inode内容未从磁盘读取</span></span><br><span class="line">    bp = bread(ip-&gt;dev, IBLOCK(ip-&gt;inum, sb));</span><br><span class="line">    dip = (struct dinode*)bp-&gt;data + ip-&gt;inum%IPB;</span><br><span class="line">    ip-&gt;type = dip-&gt;type;</span><br><span class="line">    ip-&gt;major = dip-&gt;major;</span><br><span class="line">    ip-&gt;minor = dip-&gt;minor;</span><br><span class="line">    ip-&gt;nlink = dip-&gt;nlink;</span><br><span class="line">    ip-&gt;size = dip-&gt;size;</span><br><span class="line">    memmove(ip-&gt;addrs, dip-&gt;addrs, <span class="keyword">sizeof</span>(ip-&gt;addrs));</span><br><span class="line">    brelse(bp);</span><br><span class="line">    ip-&gt;valid = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(ip-&gt;type == <span class="number">0</span>) <span class="comment">// inode未被分配，出错，引发恐慌</span></span><br><span class="line">      panic(<span class="string">"ilock: no type"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4>释放引用 iput</h4><p>释放对内存中的某一inode的引用，即引用数减一。对iput（）的所有调用必须在会话内，因为它可能释放inode。</p><p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">iput(struct inode *ip)</span><br><span class="line">&#123;</span><br><span class="line">  acquiresleep(&amp;ip-&gt;lock); <span class="comment">// 请求inode锁</span></span><br><span class="line">  <span class="comment">// 如果这是最后一个引用，则可以回收inode缓存条目。</span></span><br><span class="line">  <span class="keyword">if</span>(ip-&gt;valid &amp;&amp; ip-&gt;nlink == <span class="number">0</span>)&#123;</span><br><span class="line">    acquire(&amp;icache.lock);</span><br><span class="line">    <span class="keyword">int</span> r = ip-&gt;ref;</span><br><span class="line">    release(&amp;icache.lock);</span><br><span class="line">    <span class="keyword">if</span>(r == <span class="number">1</span>)&#123;</span><br><span class="line">      <span class="comment">// inode has no links and no other references: truncate and free.</span></span><br><span class="line">      <span class="comment">// 如果那是最后一个引用并且inode没有连接，释放磁盘上的inode（及其内容）。</span></span><br><span class="line">      itrunc(ip);</span><br><span class="line">      ip-&gt;type = <span class="number">0</span>;</span><br><span class="line">      iupdate(ip);</span><br><span class="line">      ip-&gt;valid = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  releasesleep(&amp;ip-&gt;lock); <span class="comment">// 释放 inode 锁</span></span><br><span class="line"></span><br><span class="line">  acquire(&amp;icache.lock);</span><br><span class="line">  ip-&gt;ref--; <span class="comment">// 引用计数减一</span></span><br><span class="line">  release(&amp;icache.lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4>其他函数</h4><ul><li>readsb 读超级块</li><li>bzero 将块内容清零</li><li>iupdate 将修改后的内存中inode复制到磁盘；必须在每次更改ip-&gt; xxx字段后调用；它存在于磁盘上，因为i-node缓存是直写式的；调用者必须持有i节点锁。</li><li>iunlock 对指定inode解锁</li><li>iunlockput iunlock和iput的结合。由于两种常常一起使用，故整合。</li><li>bmap 返回inode中第n个块的磁盘块地址，如果没有这样的块，bmap会分配一个。</li><li>stati 从inode复制属性信息。</li><li>readi 从inode读数据，调用者必须持有ip-&gt; lock。</li><li>writei 给inode写入数据，调用者必须持有ip-&gt; lock。</li></ul><p><em>其中readi和writei均要求给定的偏移和读出的量不超出文件大小。</em></p><h3>目录层</h3><h4>数据结构</h4><p>目录的i节点的类型是T_DIR,.目录本身是以文件的方式存储到磁盘上的，它的数据是一系列的目录条目。</p><p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> &#123;</span></span><br><span class="line">  ushort inum; <span class="comment">// i节点号</span></span><br><span class="line">  <span class="keyword">char</span> name[DIRSIZ]; <span class="comment">// 目录名</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h4>函数</h4><p>详细注释位于<code>fs.c</code>。</p><ul><li>dirlookup 查找目录中指定名字的条目</li><li>dirlink 会写入一个新的目录条目到某一目录下</li></ul><h3>路径</h3><h4>函数</h4><ul><li>namex</li></ul><p>查找并返回inode以获取路径名。如果parent！= 0，则返回父项的inode并复制最终项。路径元素到名称，必须有DIRSIZ字节的空间。该函数必须在会话内部调用，因为它调用iput（）。</p><p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">inode</span>*</span></span><br><span class="line"><span class="class"><span class="title">namex</span>(<span class="title">char</span> *<span class="title">path</span>, <span class="title">int</span> <span class="title">nameiparent</span>, <span class="title">char</span> *<span class="title">name</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">ip</span>, *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(*path == <span class="string">'/'</span>) <span class="comment">// 路径以反斜杠开始，则解析从根目录开始</span></span><br><span class="line">    ip = iget(ROOTDEV, ROOTINO);</span><br><span class="line">  <span class="keyword">else</span> <span class="comment">// 其他情况下则从当前目录开始</span></span><br><span class="line">    ip = idup(myproc()-&gt;cwd);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>((path = skipelem(path, name)) != <span class="number">0</span>)&#123; <span class="comment">// 考虑路径中的每一个部分</span></span><br><span class="line">    ilock(ip); <span class="comment">// 确保ip-&gt;type从磁盘中加载出来</span></span><br><span class="line">    <span class="keyword">if</span>(ip-&gt;type != T_DIR)&#123; <span class="comment">// 不是目录，查找失败</span></span><br><span class="line">      iunlockput(ip);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后一个路径元素，循环提前结束</span></span><br><span class="line">    <span class="keyword">if</span>(nameiparent &amp;&amp; *path == <span class="string">'\0'</span>)&#123;</span><br><span class="line">      <span class="comment">// Stop one level early. </span></span><br><span class="line">      iunlock(ip);</span><br><span class="line">      <span class="keyword">return</span> ip;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>((next = dirlookup(ip, name, <span class="number">0</span>)) == <span class="number">0</span>)&#123; <span class="comment">// 寻找路径元素失败，查找失败</span></span><br><span class="line">      iunlockput(ip);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    iunlockput(ip);</span><br><span class="line">    ip = next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(nameiparent)&#123;</span><br><span class="line">    iput(ip);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ip;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>skipelem 将路径中的下一个路径元素复制到名称中，返回指向复制后的元素的指针。</li><li>namei 解析path并返回对应的inode。</li><li>nameiparent 返回上级目录的i节点并且把最后一个元素拷贝到name中。</li></ul><p><em>函数的详细内容位于<code>fs.c</code></em></p><h3>文件描述符层</h3><p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> &#123;</span></span><br><span class="line">  <span class="keyword">enum</span> &#123; FD_NONE, FD_PIPE, FD_INODE &#125; type; <span class="comment">// 文件分为管道文件和普通文件等，FD_NONE表示文件未使用</span></span><br><span class="line">  <span class="keyword">int</span> ref; <span class="comment">// reference count 引用计数</span></span><br><span class="line">  <span class="keyword">char</span> readable; <span class="comment">// 可读</span></span><br><span class="line">  <span class="keyword">char</span> writable; <span class="comment">// 可写</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">pipe</span> *<span class="title">pipe</span>;</span> <span class="comment">// 管道</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">ip</span>;</span> <span class="comment">// 指向i节点</span></span><br><span class="line">  uint off;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>xv6中每个进程都有自己的打开文件表。每个打开文件均由上面的结构体表示，它是一个对i节点或者管道和文件偏移的封装。每次调用<code>open</code>都会创建一个新的file结构体。</p><p>如果多个进程相互独立地打开了同一个文件，不同的实例将拥有不同的I/O偏移。而且同一个file结构体可以在一个进程的文件表中多次出现，同时也可以在多个进程的文件表中出现。对每一个打开的文件都有一个引用计数，一个文件可以被打开用于读、写或者二者。</p><p>系统中所有的打开文件都存在于一个全局的文件表<code>ftable</code>中。</p><h4>函数</h4><p>该层的函数位于<code>file.c</code>，详细注释见代码文件。</p><ul><li>filealloc 分配文件，扫描整个文件表寻找没有被引用的文件并返回一个新的引用。</li><li>filedup 重复引用文件，增加引用计数。</li><li>fileclose 释放对文件引用的函数，减少引用计数，当一个文件的引用计数变为0的时候，根据文件类型的不同,释放掉当前的管道或者i节点。</li><li>fileread 读文件，实现对文件的<code>read</code>操作</li><li>filewrite 写文件，实现对文件的<code>write</code>操作。</li><li>filestat 获取文件的元信息，实现对文件的<code>stat</code>操作（只允许作用在inode）。</li></ul><h3>系统调用</h3><p>暂无内容。</p><h2>文件系统中xv6可改进之处</h2><h3>cache</h3><ol><li>使用的替换策略为LRU，算法较为简单。</li><li>链表的使用虽然实现简单，但查找效率低，时间复杂度高。若能使用哈希表等实现查找可提高效率。</li></ol><h3>目录查找</h3><p>目录查找为线性查找，在目录数量较多的情况下耗时巨大。若能使用树等结构，便能大大减小时间复杂度。</p><h3>大小固定</h3><p>文件系统的大小在xv6中是不改变的，固定在一个磁盘设备上。这一点对于个人PC影响不大，但在需要存储大量文件或超大文件的情况下，便有些捉襟见肘。</p>]]></content>
    
    <summary type="html">
    
      xv6操作系统之文件系统源码阅读与分析
    
    </summary>
    
    
      <category term="学习" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>GG</title>
    <link href="http://yoursite.com/2019/08/27/GG/"/>
    <id>http://yoursite.com/2019/08/27/GG/</id>
    <published>2019-08-26T18:12:49.000Z</published>
    <updated>2019-08-26T18:22:58.370Z</updated>
    
    <content type="html"><![CDATA[<script src="https://ajax.aspnetcdn.com/ajax/jQuery/jquery-3.4.1.min.js"></script><div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="请输入密码。" />    <label for="pass">请输入密码。</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">U2FsdGVkX1+ed9lMX8ZJ9h6gVUsUfmcpLdMB0NtPdOwjBGcczRlhNxwu4m0x2rV6m2CQZUakXyk+iH6TicF1utxR+8S5D/hX3tLpNLc4AOWwU5NL1JRNtsQLObqswFie26bEKC/5SBQcrcxkP51eQWSXhtUArz9MSBSIUajW2k0MvqO+PPSjrZ9AaqO2RFDNvyNTKA7g7t2pB8lYdLJmMTaSCQBdI+A0WnDQvWbzGry+mW4fQtAwxUXie6JO7/GQLf+c9LkIZCM5O4hfUMwneKwWlJYTACh+7Wc/rC2jiUBt+dgSVOXO6iC1JJ6QyApNepy3wDn6J29kFploeebF835h2WrE0NNf5witEoz4c1Kiw6RKQoOXKc6X716cDZDVnURYzEHeC8TyLOXNZ0gmg895jtNM4j2i1bIpeIugMD0cg2ApLmab6UuOcXR9iVTzgC/45Mw60RNg7n+WQ9UsgrajXqzOcHKVeC/z/inkjZt3zNsLzM67Eu0maYL0e411MpDjI7uTwBmblv6I6yaghBV9ftkJoT6oCFKMCH0dNsXhLHf8Ulw5ISTNr4TsqNqffFpLa+c3LJLp2y26n7EFK0/vaGgcDWm7kt3cVzZR6xvVzipPhKXyjelJ/aXI270oJPwk/Cd4NMc0RHTzeIMyPrGXuzfgSm5XTNqjcCLs5tF9nz3nOyFY3GBC2RwKEyN5JogAgb25yhL84qPgSW4W/zje8xvoxruaNDN/86FCangMWZAC2NFCmNZtc2piqzDduce3LCC7T1C5KbVdTg/pw+FPp6tZ5zMfuP4LEMbLYRvzF3MCLcjvqcbcRpT9CpAYm7PcJf2u3vx5GNkeuNdj01XeDRkfPZR/MAExBKMQCBo7ihbBWtNHMYHId+YsLYxPMAgE6E3KEfSHA2BXeXdq5D5Oy0CDBfm4qSoYFBU3U9iJ6+Kzvb0wJurg9goq9NfvCJkR4d3r1bPqzNIJLTStIdfpbzxWVJ8eaHVc69Qu655IwbPThDH/tq/ik//8ugzPIAQc5ubsUXIQBeV7uywsQ/Uyj70PRxI4os5raZrh8r7bGWdJwDAOCiswfRx1dYHycFwrVhriNOI79hrxXG5biwzg/GivbCksRU12em3lzU5gHhmDS2gwtVAa8aVEesZFBewpMWtpWFeN6pHjU7Q0C0FhFkZasErj4kPr/DIJn+wDSAjRNHFnhraJEec+T068EI7OPPxOqAz+cVLw2H2o5TthHv+VDb/OfArtwUO2gpEFF+VZyHyebVCTdzjB5mHiBOsB2yDg3v+f/sSVJ7f0+fFPIJzakKRJOuE9nvpQnw8xL6HrN06w0CI3GeTfkAAXvsTtCTGAT4sdW+SM4fsBaD4JhG6EI2KBRsLISY9L0hkQlKwfGaHekRzNRYw+ohhwhmlnkmMjvDYxRctf9iVXbcU3nFZJ1XO40JXRO+SDUlI5akeqkqIVcBivXBjl0N6rcSWRXchF/ezwXslABQXwowCUS0SKAEYU+eoqCMvvtyBKW+1SSboU133RMBFrAyCwSVWQ+1I3/GNCeqYcR4y5mJnK93f4tr7JpWBKvNCOkUR/bbMllQFcKAno1I3IXRsYIE8wD91CRllkffB9DCPQnG20WvoaYTwy3/+CvnxHpgu3lO4rdjMM+IyLCQ3JTV1NIQVHb5ki0Vs4XMbOtEZLT1VDeo+sIaAMx6Q2u7x8cD7StAzd9HueV3T9efbx2xcN8sxVbSw19m6F/yE/tPTC9qnZrf+6k+PTU9okVFOzoPVK/EDuYC17kNeqCbSOYMbEsLp5rdGaNrpqh2DVvcIgILs3YL2mYx7J/5T4SNIa96xidRaWlQ2CuoM3xjpHM2wsl5M/K2ihb4pWGeDJkNBtFQwKgCHo5S8ILpDF9TEaP4alG1UQ+okfobVJp0d1BGQU1Li9tD6dl/QAlYZjZDYyBu1BMMEGFJ9WCG0forjNC7jpIN29Kfax80LK5KOcEK/mNS7mlKjv+zJE/tw62EU5IK4Mij2bWPStNXG8SWaq/gul6DCTMj/SZmDV8N6bWLETX0IiO/pJTaM1DuRHkRCXqtJBnESybn2FJwbgBaxfcldrxSPEjV9EBtehjmGPTW4HP1AS9WshaPEZq6Qyy/GphsCGDz24iI4xJt/SO3+q4VYZ7DwmGz8KC0QusfLwBoygfHSJAqna98b1SFtzGUPdcP3kqThmZYltJsGZM0WxVpBKDma9vpWCDAvh+31IKIfwaaEg6kD8QO5PfIu1AfRPEh48LuQ9MgHtFOEypYBj9YX4NFsTzPp3eXGNKaErNARKFxNtBaZ1ZehPUMBobPMvFox88o30usECi7kSx2slcNAX9JvIOUQZcau5lBLXhaTojIr7lXTZlxuZDKOZ6o9VW47J77e6Z2twWaEP8kij12Iwew0GMWutxWPLcD1W3fg0exXlgBulOyPp7Fm3u8c2cLePfPlWBZBGfCMJQ2TsP5RCLotExGg4myIR7GC6hCaSXiP3Ilqo/Ji+ia+vMatCqwAl9+7yUjk8L5NnI6yJghyi0hCRCs6X1KhWKRYBdHod96+fTS1X3vLvrkKXt56Fa/oEuaPJIhH7teWQfioFLdh1pSRYPiMQm/EQrKneRVGhUGywYfmQ32sbllk/VjQqRWnqdKVaSw9YRqanZBwUBxw+aGTxmmlbavs7gOtyUkjkAsgxbB+04njLDtFDy58ymxiuDuAELFfNLrBzwt2Iow4GUa1hT14+lcTNBpnpKBC37Sm7yKBPsS/siMNOGofcB7EVtpkFyZHOMcqejovWrS0DWV3p/TIKh9GzGXljbN29W0dfBEPPd3v7ezaQ97r8D9P+sGzzPudbR9IqOLOJh8xuqhOz2RIUuajSw14eNBlTrnV3oGzOCXkN/70GK8cUFvwNrrAuSTWWN2RglikwPE494iRf0VQq9REFQkgpyPlByhI0QhY7OEVpkJk64MSigQObRQkS2BpUFzbpZHgMH/9zl6rVWhJZESU1DZlBefTfn5bcjhtAN+bSqJ25WkK/Xm+drLY5kYTXqhwY5lkA9gE3B9+bGVmm7RMfy0u37S84zzMCEiD9N9qGVdZ0qqUOunhOBjhj4uZYILBxO+ibPaQQBTgpkrXzD8RfkPGG0ebKKs0eGCVKa1lat7dyS6MI97lyn5eYR5plaGIlu3i8iRsQhtxZsySS5BsBcKHAMvkimk5yH3i9ckYk//dhktY2NBPR1z+WfhnCxCxqcKtv/T3hMRT0hnsk5mFYhKFmFUj9LYB8gb8q7L+MYThevFKVs1d4wPum7ouDSK59FobhaHbuWKnyWn4u1D6VqGb/RdRXPWHuzEwNYjCf7CL46VJVlyHtsmL+wx4IEQavBqO36Nhw4p3mPJADh6c1cKMUmtfKdthkXacawqIF42kV98A3MOLjZyGcLQiZAfGmRxtlB4hydlaKACt/EnLNPfzAdjhijOz/HknxFnzltGOUsLY3+sNb0qAAIzvOeEBHy3w72CeKpiUpSUNLdjPRqdSDFTTR2SiX7Pj0ULbs3lxHTIg3YcdEdG6x1vT2lB+QlsbraFBCPXFdI2C2Qs6eeCbpQgqfucL+gNypq6PTi7ypfmT7M6U9/MhNR/pEAumbb7+mEzKW1IZofgCW2jveLw/fFs2UkciJ4IIzZ01Avz/EvexwYztuamnEQv/raCPDjty+/+AlnfdU5reWtyjUliPLv5dwVYQMBWHxqpUz3cbabDYt8dvOiS9cPX9p7/uT6fLpS4ejvx2TZCG0ULhqN3IaVUaF/cYFeLiyO7wxRFMLfqBEeNbedzWGykTnHFb/1tgs9zAI207zhh0L8rG4pYIEjonRyS4tvzyij+hl+lnn1jhNjoOQUlbUT1rXIMXF5huA0caGfLIFeMRl4wreQBqELmpW</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      What is that?
    
    </summary>
    
    
      <category term="随笔" scheme="http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>世界</title>
    <link href="http://yoursite.com/2019/08/06/HK/"/>
    <id>http://yoursite.com/2019/08/06/HK/</id>
    <published>2019-08-06T10:41:51.000Z</published>
    <updated>2019-08-06T11:01:07.349Z</updated>
    
    <content type="html"><![CDATA[<script src="https://ajax.aspnetcdn.com/ajax/jQuery/jquery-3.4.1.min.js"></script><div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="请输入密码。" />    <label for="pass">请输入密码。</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      弱势群体的和平抗争
    
    </summary>
    
    
      <category term="随笔" scheme="http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>建站日志</title>
    <link href="http://yoursite.com/2019/07/26/%E5%BB%BA%E7%AB%99%E6%97%A5%E5%BF%97/"/>
    <id>http://yoursite.com/2019/07/26/建站日志/</id>
    <published>2019-07-26T06:00:02.000Z</published>
    <updated>2019-08-06T11:15:35.856Z</updated>
    
    <content type="html"><![CDATA[<h2>主题Next</h2><p>一开始选用的是<a href="https://github.com/litten/hexo-theme-yilia" target="_blank" rel="noopener">Yilia</a>,但由于<a href="https://github.com/litten/hexo-theme-yilia" target="_blank" rel="noopener">Yilia</a>开发使用的webpack版本较老，定制时易踩坑，故改用<a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">Next</a>。本文根据官方文档整理，并根据自己喜好加入了一些第三方插件和修改。所有修改将会逐步给出，Next的配置完整说明可参照<a href="http://theme-next.iissnan.com" target="_blank" rel="noopener">官方文档</a>。</p><p>&lt;!--more--&gt;</p><h2>基本配置</h2><h3>下载</h3><p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> 博客根目录</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure></p><h3>启用</h3><p>打开根目录中的 <code>_config.yml</code> 文件,更改 <code>theme</code> 为 <code>next</code> 。</p><p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">next</span></span><br></pre></td></tr></table></figure></p><h3>选择Scheme</h3><p>打开 <code>theme/next</code> 中的 <code>_config.yml</code> 文件，选择 <code>Muse</code> 。</p><p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Schemes</span></span><br><span class="line"><span class="attr">scheme:</span> <span class="string">Muse</span></span><br><span class="line"><span class="comment">#scheme: Mist</span></span><br><span class="line"><span class="comment">#scheme: Pisces</span></span><br><span class="line"><span class="comment">#scheme: Gemini</span></span><br></pre></td></tr></table></figure></p><h3>切换语言</h3><p>打开根目录中的 <code>_config.yml</code> 文件,设置 <code>language</code> 为 <code>zh-Hans</code> 。</p><h2>自定义</h2><h3>主页文章阴影效果</h3><p>打开 <code>themes/next/source/css/_custom/custom.styl</code> ,增加</p><p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 主页文章添加阴影效果</span><br><span class="line"> <span class="selector-class">.post</span> &#123;</span><br><span class="line">   <span class="attribute">margin-top</span>: <span class="number">60px</span>;</span><br><span class="line">   <span class="attribute">margin-bottom</span>: <span class="number">60px</span>;</span><br><span class="line">   <span class="attribute">padding</span>: <span class="number">25px</span>;</span><br><span class="line">   <span class="attribute">-webkit-box-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">5px</span> <span class="built_in">rgba</span>(202, 203, 203, .5);</span><br><span class="line">   <span class="attribute">-moz-box-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">5px</span> <span class="built_in">rgba</span>(202, 203, 204, .5);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><h3>修改标签</h3><p>打开 <code>themes/next/layout/_macro/post.swig</code> ，搜索 <code>rel=&quot;tag&quot;&gt;#</code>，将 <code>#</code> 换成 <code>&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt;</code> 。</p><h3>动态背景</h3><p>打开 <code>theme/next/layout/_layout.swig</code> ，在 &lt; /body&gt;之前添加代码</p><p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if theme.canvas_nest %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure></p><p>打开 <code>theme/next</code> 中的 <code>_config.yml</code> 文件,将 <code>canvas_next</code> 置为 <code>true</code> 。</p><p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">canvas_nest:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></p><h3>看板狗</h3><p>安装</p><p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-helper-live2d --save</span><br><span class="line">npm install live2d-widget-model-wanko</span><br></pre></td></tr></table></figure></p><p>打开根目录中的 <code>_config.yml</code> 文件,增加以下代码。其中对 <code>display</code> 部分做了修改，以适应网页布局。</p><p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Live2D</span></span><br><span class="line"><span class="comment">## https://github.com/EYHN/hexo-helper-live2d</span></span><br><span class="line"><span class="attr">live2d:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># enable: false</span></span><br><span class="line"><span class="attr">  scriptFrom:</span> <span class="string">local</span> <span class="comment"># 默认</span></span><br><span class="line"><span class="attr">  pluginRootPath:</span> <span class="string">live2dw/</span> <span class="comment"># 插件在站点上的根目录(相对路径)</span></span><br><span class="line"><span class="attr">  pluginJsPath:</span> <span class="string">lib/</span> <span class="comment"># 脚本文件相对与插件根目录路径</span></span><br><span class="line"><span class="attr">  pluginModelPath:</span> <span class="string">assets/</span> <span class="comment"># 模型文件相对与插件根目录路径</span></span><br><span class="line">  <span class="comment"># scriptFrom: jsdelivr # jsdelivr CDN</span></span><br><span class="line">  <span class="comment"># scriptFrom: unpkg # unpkg CDN</span></span><br><span class="line">  <span class="comment"># scriptFrom: https://cdn.jsdelivr.net/npm/live2d-widget@3.x/lib/L2Dwidget.min.js # 你的自定义 url</span></span><br><span class="line"><span class="attr">  tagMode:</span> <span class="literal">false</span> <span class="comment"># 标签模式, 是否仅替换 live2d tag标签而非插入到所有页面中</span></span><br><span class="line"><span class="attr">  debug:</span> <span class="literal">false</span> <span class="comment"># 调试, 是否在控制台输出日志</span></span><br><span class="line"><span class="attr">  model:</span></span><br><span class="line"><span class="attr">    use:</span> <span class="string">live2d-widget-model-wanko</span> <span class="comment"># npm-module package name</span></span><br><span class="line">    <span class="comment"># use: wanko # 博客根目录/live2d_models/ 下的目录名</span></span><br><span class="line">    <span class="comment"># use: ./wives/wanko # 相对于博客根目录的路径</span></span><br><span class="line">    <span class="comment"># use: https://cdn.jsdelivr.net/npm/live2d-widget-model-wanko@1.0.5/assets/wanko.model.json # 你的自定义 url</span></span><br><span class="line"><span class="attr">  display:</span></span><br><span class="line"><span class="attr">    position:</span> <span class="string">right</span></span><br><span class="line"><span class="attr">    width:</span> <span class="number">200</span></span><br><span class="line"><span class="attr">    height:</span> <span class="number">400</span></span><br><span class="line">    <span class="comment"># 水平位置</span></span><br><span class="line"><span class="attr">    hOffset:</span> <span class="number">40</span></span><br><span class="line">    <span class="comment"># 垂直位置</span></span><br><span class="line"><span class="attr">    vOffset:</span> <span class="bullet">-80</span></span><br><span class="line"><span class="attr">  mobile:</span></span><br><span class="line"><span class="attr">    show:</span> <span class="literal">true</span> <span class="comment"># 手机中是否展示</span></span><br></pre></td></tr></table></figure></p><h3>Github Corners</h3><p>打开<a href="http://tholman.com/github-corners/" target="_blank" rel="noopener">Github Corners</a>,复制代码并粘贴代码到 <code>themes/next/layout/_layout.swig</code> 文件中(放在 <code>&lt;div class=&quot;headband&quot;&gt;&lt;/div&gt;</code> 的下面)，并把 <code>href</code> 改为正确的github地址。</p><p>由于比较喜欢这个小家伙一直出现，故更改代码中的 <code>position: absolute</code> 为 <code>position: fixed</code> 。</p><p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"headband"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&lt;a href=<span class="string">"https://github.com/RootReturn0"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"github-corner"</span> aria-label=<span class="string">"View source on GitHub"</span>&gt;<span class="xml"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">"80"</span> <span class="attr">height</span>=<span class="string">"80"</span> <span class="attr">viewBox</span>=<span class="string">"0 0 250 250"</span> <span class="attr">style</span>=<span class="string">"fill:#151513; color:#fff; position: fixed; top: 0; border: 0; right: 0;"</span> <span class="attr">aria-hidden</span>=<span class="string">"true"</span>&gt;</span><span class="tag">&lt;<span class="name">path</span> <span class="attr">d</span>=<span class="string">"M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"</span>&gt;</span><span class="tag">&lt;/<span class="name">path</span>&gt;</span><span class="tag">&lt;<span class="name">path</span> <span class="attr">d</span>=<span class="string">"M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"</span> <span class="attr">fill</span>=<span class="string">"currentColor"</span> <span class="attr">style</span>=<span class="string">"transform-origin: 130px 106px;"</span> <span class="attr">class</span>=<span class="string">"octo-arm"</span>&gt;</span><span class="tag">&lt;/<span class="name">path</span>&gt;</span><span class="tag">&lt;<span class="name">path</span> <span class="attr">d</span>=<span class="string">"M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"</span> <span class="attr">fill</span>=<span class="string">"currentColor"</span> <span class="attr">class</span>=<span class="string">"octo-body"</span>&gt;</span><span class="tag">&lt;/<span class="name">path</span>&gt;</span><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><span class="xml"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"><span class="selector-class">.github-corner</span><span class="selector-pseudo">:hover</span> <span class="selector-class">.octo-arm</span>&#123;<span class="attribute">animation</span>:octocat-wave <span class="number">560ms</span> ease-in-out&#125;@<span class="keyword">keyframes</span> octocat-wave&#123;0%,100%&#123;<span class="attribute">transform</span>:<span class="built_in">rotate</span>(0)&#125;20%,60%&#123;<span class="attribute">transform</span>:<span class="built_in">rotate</span>(-25deg)&#125;40%,80%&#123;<span class="attribute">transform</span>:<span class="built_in">rotate</span>(10deg)&#125;&#125;@<span class="keyword">media</span> (max-width:<span class="number">500px</span>)&#123;<span class="selector-class">.github-corner</span><span class="selector-pseudo">:hover</span> <span class="selector-class">.octo-arm</span>&#123;<span class="attribute">animation</span>:none&#125;<span class="selector-class">.github-corner</span> <span class="selector-class">.octo-arm</span>&#123;<span class="attribute">animation</span>:octocat-wave <span class="number">560ms</span> ease-in-out&#125;&#125;</span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p><h3>RSS</h3><p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> 博客根目录</span><br><span class="line">npm install hexo-generator-feed --save</span><br></pre></td></tr></table></figure></p><p>打开根目录中的 <code>_config.yml</code> 文件,添加</p><p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: http://hexo.io/plugins/</span></span><br><span class="line"><span class="attr">plugins:</span> <span class="string">hexo-generate-feed</span></span><br></pre></td></tr></table></figure></p><p>打开 <code>theme/next</code> 中的 <code>_config.yml</code> 文件,在 <code>rss</code> 后添加 <code>/atom.xml</code></p><p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Set rss to false to disable feed link.</span></span><br><span class="line"><span class="comment"># Leave rss as empty to use site's feed link.</span></span><br><span class="line"><span class="comment"># Set rss to specific value if you have burned your feed already.</span></span><br><span class="line"><span class="attr">rss:</span> <span class="string">/atom.xml</span></span><br></pre></td></tr></table></figure></p><h2>加密</h2><p>有时写博客并不希望让所有人看到，故加入了加密功能。Hexo是一个静态博客，自己写一个js进行加密虽不困难，但样式实在不可恭维。这里采用大神做出的<a href="https://github.com/MikeCoder/hexo-blog-encrypt/blob/master/ReadMe.zh.md" target="_blank" rel="noopener">hexo-blog-encrypt</a>进行加密。</p><h3>安装</h3><p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> 博客根目录</span><br><span class="line">npm install hexo-blog-encrypt --save</span><br></pre></td></tr></table></figure></p><h3>配置</h3><h4>根本配置</h4><p>打开根目录中的 <code>_config.yml</code> 文件,添加</p><p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">encrypt:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></p><h4>自定义配置</h4><p>然后在blog的头部添加上对应的字段，如password, abstract, message。</p><p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 文章加密</span><br><span class="line">date: 2019-08-06 19:00:02</span><br><span class="line">password: 你的密码</span><br><span class="line">abstract: 显示在目录页或首页的内容简介。</span><br><span class="line">message:  此处为输入密码时的提示内容。</span><br><span class="line">---</span><br></pre></td></tr></table></figure></p><h4>全局配置</h4><p>希望修改默认的提示和摘要内容时，你可以添加如下配置在根目录中的 <code>_config.yml</code> 文件中。</p><p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">encrypt:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  default_abstract:</span> <span class="string">这是一篇加密文章，内容可能是xxx</span></span><br><span class="line"><span class="attr">  default_message:</span> <span class="string">输入密码，查看文章。</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2&gt;主题Next&lt;/h2&gt;
&lt;p&gt;一开始选用的是&lt;a href=&quot;https://github.com/litten/hexo-theme-yilia&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Yilia&lt;/a&gt;,但由于&lt;a href=&quot;https://
      
    
    </summary>
    
    
      <category term="日志" scheme="http://yoursite.com/tags/%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>hello world</title>
    <link href="http://yoursite.com/2019/07/25/hello-world/"/>
    <id>http://yoursite.com/2019/07/25/hello-world/</id>
    <published>2019-07-25T12:43:01.000Z</published>
    <updated>2019-07-26T14:28:49.946Z</updated>
    
    <content type="html"><![CDATA[<p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"Hello world!"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    <span class="title">print</span><span class="params">(<span class="string">'Hello world!'</span>)</span></span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span clas
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ILY</title>
    <link href="http://yoursite.com/2019/07/25/ILY/"/>
    <id>http://yoursite.com/2019/07/25/ILY/</id>
    <published>2019-07-25T11:26:00.000Z</published>
    <updated>2019-07-25T11:58:50.263Z</updated>
    
    <content type="html"><![CDATA[<p>I am here. A ghost.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;I am here. A ghost.&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="随笔" scheme="http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
</feed>
