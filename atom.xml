<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>〇</title>
  
  <subtitle>世界的本质即是无限的循环</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://rootreturn0.github.io/"/>
  <updated>2020-06-24T22:46:51.788Z</updated>
  <id>http://rootreturn0.github.io/</id>
  
  <author>
    <name>rootReturn0</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>三封信</title>
    <link href="http://rootreturn0.github.io/2020/06/25/%E4%B8%89%E5%B0%81%E4%BF%A1/"/>
    <id>http://rootreturn0.github.io/2020/06/25/三封信/</id>
    <published>2020-06-24T21:28:48.000Z</published>
    <updated>2020-06-24T22:46:51.788Z</updated>
    
    <content type="html"><![CDATA[<script src="https://ajax.aspnetcdn.com/ajax/jQuery/jquery-3.4.1.min.js"></script><div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="他的名字" />    <label for="pass">他的名字</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      逝者已逝，信件犹在
    
    </summary>
    
      <category term="Me" scheme="http://rootreturn0.github.io/categories/Me/"/>
    
    
      <category term="随笔" scheme="http://rootreturn0.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>共情</title>
    <link href="http://rootreturn0.github.io/2020/04/11/%E5%85%B1%E6%83%85/"/>
    <id>http://rootreturn0.github.io/2020/04/11/共情/</id>
    <published>2020-04-11T08:46:20.000Z</published>
    <updated>2020-04-11T09:44:32.216Z</updated>
    
    <content type="html"><![CDATA[<h2 id="刺客信条"><a href="#刺客信条" class="headerlink" title="刺客信条"></a>刺客信条</h2><p>刺客信条是我第一次接触的 3A 大作。在高考结束后，我买了 Xbox One 的手柄，玩起了《刺客信条2》。</p><p>一边熟悉着新奇的游戏，一遍熟悉着奇怪的手柄。</p><p>笨拙地打架，笨拙地逃跑，熟练地爬上窗去偷情。而后盲目却不失风度地走上了复仇之路。Ezio 的故事里，我笑过，怒过，悲伤过。我享受着 Ezio 的人生，潇洒，责任，和彬彬无礼。</p><p>之后我就迷恋上了刺客信条系列，从 Altair到《刺客信条：起源》，我几乎没有落下什么。但我仍不能说是刺客的粉丝，你看，我连起源里刺客的名字都不记得了。</p><p>Conner 的独立战争我也参与了。刺客信条第三部确实不能被称上一个好游戏，因为我的记忆里实在没有什么令我印象深刻的片段，除了他和他父亲的故事。我不想杀 Haytham Kenway，我认识到刺客的世界里的骑士不一定是黑暗的秩序。但这是一条单线游戏，于是我杀了他。我在游戏里开始有了思考，这确实是一款好游戏。</p><p>Edward 的“上天入地寒鸦号”。《刺客信条：黑旗》的海战畅快淋漓，导致我再次忘记剧情是什么了。依稀记得这是一个捡到别人衣服最终被说服入伙的故事。我又可以只盯着目标打架，而不是思考目标的好坏。毕竟我是个善良的海盗嘛。</p><p>这是一条分割线，随心与动脑的分割线。</p><p>可能由于前几代的敌人都太弱了，《刺客信条：大革命》后的刺客不再能无双式潜入。此时需要观察战斗地点，无声潜入。我不是一个喜欢消耗品的人，因此除了教学使用烟雾弹，我在这里面没有使用过任何一次烟雾弹，导致游戏难度直线上升。我精心策划着每一次潜入，每一次刺杀，每一次潜逃。于是我对剧情的记忆更加深刻，这里的骑士与刺客更加不分明了。但有个地方我记不清了：有一个人，我不想杀。我不记得是谁，也不记得为什么杀他，我只记得我不想杀，我抗拒这次任务。但我还是得杀，否则游戏就进行不下去了。我又开始精心策划我的刺杀，一遍一遍地踩点，计算巡逻路线，寻找绝佳的刺杀位置和逃脱手段。</p><p>于是他死了。</p><p>再之后的刺客，我便变得像看电影一样了。也就是说，我越来越难以代入游戏角色了。机械地执行杀戮，机械地完成（finish）任务目标。我的游戏世界越来越追求成就和完成任务。但我很懒，从来没有一个游戏能做到全成就。</p><h2 id="星露谷物语"><a href="#星露谷物语" class="headerlink" title="星露谷物语"></a>星露谷物语</h2><p>听说这游戏很休闲，我便趁打折的时候购入了。确实很休闲，2 天玩了 36 小时。</p><p>在星露谷里，可以种田、养猪、酿酒和追求小姐姐。</p><p>我喜欢莉亚。</p><p>但我又陷入了追求更快完成任务的怪圈。我疯狂赚钱，顺便追求小姐姐。为了十心成就，我又分心同时追了好多小哥哥小姐姐老阿姨老叔叔和小朋友。</p><p>第二年冬天，我终于刷完了我所想要的大部分成就和足够花的钱（因为没经验，虽然钱足够花，但不多）。我终于能和莉亚小姐姐结婚了。但我忽然没了兴趣，莉亚小姐姐也提不起我的兴趣。我和她的婚礼三天后就举办了，但我甚至不想再打开游戏。我没有不喜欢，没有厌烦，仅仅是不想。</p><p>我没有融入到星露谷的生活里。他们是鲜活的，温暖的，但冰冷的 NPC。</p><p>我不知道我玩游戏是为了什么。没有快感，仅仅只是消遣吗？</p><h2 id="集合啦！动物森友会"><a href="#集合啦！动物森友会" class="headerlink" title="集合啦！动物森友会"></a>集合啦！动物森友会</h2><p>我忍不住买了。很贵。非常贵。但幸好我没有一起玩的朋友，可以省下微薄的会员钱。</p><p>其实也不是没有朋友，但我很怕朋友约我，而我又经常有事情。虽然大部分时候都在摸鱼，但总觉得自己有事情。</p><p>这是一个要花一年才能玩完的游戏。</p><p>第一天，我沉迷钓鱼。可能还房贷又成为了我疯狂想要完成的任务。</p><p>第二天，我开始体验新的生活。</p><p>第三天，…</p><p>动森的慢节奏强迫我慢了下来，我开始一点一点不再只是追求完成目标。毕竟不管再怎么高效，我也没法在一天内通关动森吧（笑）。但我是一个讨厌浪费时间的人，在Nook集里游+开放后，我总是想在做一个任务的同时顺便多完成几个任务。</p><p>不过在动森一天天的佛系调教下，我成为了一个玩游戏顺便完成任务的人。我似乎又开始感受到了游戏的乐趣。</p><p>但我终究还是不能融入动森的世界里。狸克人很好，傅达很可爱，居民们也很善良，岛外的居民也很信任我。但这一切都与我无关。</p><hr><p>我拥有，我没有，我获得，我想失去。</p><p>也许在哪个世界，我都格格不入。</p><div style="display: none">杀了我，趁我还清醒。</div>]]></content>
    
    <summary type="html">
    
      游戏人生
    
    </summary>
    
    
      <category term="随笔" scheme="http://rootreturn0.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>Ubantu 18.04 修改分辨率</title>
    <link href="http://rootreturn0.github.io/2020/04/02/Ubantu%20%E5%88%86%E8%BE%A8%E7%8E%87/"/>
    <id>http://rootreturn0.github.io/2020/04/02/Ubantu 分辨率/</id>
    <published>2020-04-01T19:33:18.000Z</published>
    <updated>2020-04-01T20:21:28.863Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Ubuntu-18-04-分辨率（xrandr无效，使用xdiagnose）"><a href="#Ubuntu-18-04-分辨率（xrandr无效，使用xdiagnose）" class="headerlink" title="Ubuntu 18.04 分辨率（xrandr无效，使用xdiagnose）"></a>Ubuntu 18.04 分辨率（xrandr无效，使用xdiagnose）</h1><p>Ubantu 18.04 安装后使用<code>xrandr</code>查看分辨率，发现分辨率只有 800 x 600 的选项。</p><p>首先在网上百度，大多数结果都是使用<code>cvt</code>+<code>xrandr</code>进行修改。然而实际操作过程中，一直无法解决报错<code>failed to get size of gamma for output default</code>。</p><p>而后发现使用<code>xdiagnose</code>成功解决问题。</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol><li>下载<code>xdiagnose</code>。<code>xdiagnose</code>并非系统自带，直接使用会发生命令未找到的错误。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install xdiagnose</span><br></pre></td></tr></table></figure><ol start="2"><li>打开<code>xdiagnose</code>的配置界面。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo xdiagnose</span><br></pre></td></tr></table></figure><ol start="3"><li>如下图所示，把 <strong>Debug</strong> 部分全部勾上。</li></ol><img src="https://tva1.sinaimg.cn/large/00831rSTgy1gdevwcovztj30hi0h6n5n.jpg" alt="xdiagnose" style="zoom:50%;"><ol start="4"><li>重启，屏幕自动适配。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reboot</span><br></pre></td></tr></table></figure><h2 id="选择分辨率"><a href="#选择分辨率" class="headerlink" title="选择分辨率"></a>选择分辨率</h2><p>重启后可在<code>系统设置 -&gt; 设备 -&gt; 显示</code>中选择分辨率，通过<code>xrandr</code>查看也可看到其他分辨率。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Ubuntu-18-04-分辨率（xrandr无效，使用xdiagnose）&quot;&gt;&lt;a href=&quot;#Ubuntu-18-04-分辨率（xrandr无效，使用xdiagnose）&quot; class=&quot;headerlink&quot; title=&quot;Ubuntu 18.04 分辨率
      
    
    </summary>
    
    
      <category term="学习" scheme="http://rootreturn0.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Silence</title>
    <link href="http://rootreturn0.github.io/2020/01/01/Silence/"/>
    <id>http://rootreturn0.github.io/2020/01/01/Silence/</id>
    <published>2019-12-31T18:34:51.000Z</published>
    <updated>2019-12-31T18:39:02.480Z</updated>
    
    <content type="html"><![CDATA[<p>它来了，我没有动；</p><p>它没有走，我没有动；</p><p>它走了，我没有动。</p><p>什么都没有改变，一如既往的平静。</p><p>正如我的笔下依旧没有花。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;它来了，我没有动；&lt;/p&gt;
&lt;p&gt;它没有走，我没有动；&lt;/p&gt;
&lt;p&gt;它走了，我没有动。&lt;/p&gt;
&lt;p&gt;什么都没有改变，一如既往的平静。&lt;/p&gt;
&lt;p&gt;正如我的笔下依旧没有花。&lt;/p&gt;

      
    
    </summary>
    
      <category term="Me" scheme="http://rootreturn0.github.io/categories/Me/"/>
    
    
      <category term="随笔" scheme="http://rootreturn0.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>无题</title>
    <link href="http://rootreturn0.github.io/2019/12/13/%E6%97%A0%E9%A2%98/"/>
    <id>http://rootreturn0.github.io/2019/12/13/无题/</id>
    <published>2019-12-12T17:05:34.000Z</published>
    <updated>2019-12-12T17:38:51.444Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p> 冬日的思绪总是不受控制，在休息不足时尤是如此。</p></blockquote><h2 id="Part-1"><a href="#Part-1" class="headerlink" title="Part 1"></a>Part 1</h2><p>一日看尽长安花。长安是哪里？</p><p>在遥远的天际线上，辉映着晶莹剔透的云景；在可及的地平线上，闪耀着混合多彩的阳光。</p><p>但愈是前进，愈加惊觉地球是存在于三维空间中的球体。那些美妙的光景仿佛坠入了四维位面——当发现无比接近时，却打不破维度的限制，再向前，渐行渐远；而后那光景变换了位置，无论如何向前，距离都不会发生变化。</p><p>翻山越岭，遇见山崩；蜉蝣渡海，撞见海啸。但我仍保有跨过山和大海的希望。可是维度的封锁我要如何越过？</p><hr><h2 id="Part-2"><a href="#Part-2" class="headerlink" title="Part 2"></a>Part 2</h2><p>我以为我把天修好了。</p><p>我只是把它扛起来了，让它不至于掉下去。</p><p>可是手好酸。</p><p>——我的力气在流逝。</p>]]></content>
    
    <summary type="html">
    
      在不同的季节和时间里，阳光是多变的。
    
    </summary>
    
      <category term="Me" scheme="http://rootreturn0.github.io/categories/Me/"/>
    
    
      <category term="随笔" scheme="http://rootreturn0.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>返回顶部</title>
    <link href="http://rootreturn0.github.io/2019/11/12/%E8%BF%94%E5%9B%9E%E9%A1%B6%E9%83%A8/"/>
    <id>http://rootreturn0.github.io/2019/11/12/返回顶部/</id>
    <published>2019-11-12T05:50:12.000Z</published>
    <updated>2019-11-12T07:07:13.455Z</updated>
    
    <content type="html"><![CDATA[<p>本文参考<a href="http://yearito.cn/posts/hexo-theme-beautify.html" target="_blank" rel="noopener">yearito</a>的博客。</p><p>最终在博客中产生了莫名萌的效果（</p><img src="//rootreturn0.github.io/2019/11/12/返回顶部/DogAndCat.png" width="200"><h2 id="下载图片"><a href="#下载图片" class="headerlink" title="下载图片"></a>下载图片</h2><p>点击下方按钮可下载本站使用的图片。</p><p><a class="btn" href="//rootreturn0.github.io/images/scroll.png" target="_blank" rel="noopener"><i class="fa fa-download fa-fw"></i>下载图片</a></p><blockquote><p>实际上什么图片都可以，放到 <code>source\images\</code> 目录下即可</p></blockquote><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>然后在自定义样式文件 <code>themes\next\source\css\_custom\custom.styl</code> 中添加如下代码：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//自定义回到顶部样式</span><br><span class="line"><span class="selector-class">.back-to-top</span> &#123;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">60px</span>;</span><br><span class="line">  width: 70px;  //图片素材宽度</span><br><span class="line">  height: 900px;  //图片素材高度</span><br><span class="line">  <span class="selector-tag">top</span>: <span class="selector-tag">-900px</span>;</span><br><span class="line">  <span class="selector-tag">bottom</span>: <span class="selector-tag">unset</span>;</span><br><span class="line">  <span class="selector-tag">transition</span>: <span class="selector-tag">all</span> <span class="selector-class">.5s</span> <span class="selector-tag">ease-in-out</span>;</span><br><span class="line">  background: url("/images/scroll.png");</span><br><span class="line"></span><br><span class="line">  //隐藏箭头图标</span><br><span class="line">  &gt; <span class="selector-tag">i</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: none;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &amp;<span class="selector-class">.back-to-top-on</span> &#123;</span><br><span class="line">    <span class="attribute">bottom</span>: unset;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">100vh</span> &lt; (<span class="number">900px</span> + <span class="number">200px</span>) ? <span class="built_in">calc</span>( 100vh - 900px - 200px ) : <span class="number">0px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      修改返回顶部样式为猫猫🐱
    
    </summary>
    
      <category term="建站日志" scheme="http://rootreturn0.github.io/categories/%E5%BB%BA%E7%AB%99%E6%97%A5%E5%BF%97/"/>
    
    
      <category term="日志" scheme="http://rootreturn0.github.io/tags/%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>Android学习笔记_UI</title>
    <link href="http://rootreturn0.github.io/2019/10/20/Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-UI/"/>
    <id>http://rootreturn0.github.io/2019/10/20/Android学习笔记-UI/</id>
    <published>2019-10-20T07:05:32.000Z</published>
    <updated>2019-10-20T11:14:09.078Z</updated>
    
    <content type="html"><![CDATA[<p>笔记基于<a href="https://me.csdn.net/sinyu890807" target="_blank" rel="noopener">郭霖大神</a>所著的<a href="https://blog.csdn.net/guolin_blog/article/details/52032038" target="_blank" rel="noopener">《第一行代码》第二版</a>之第3章。该系列笔记主要目的在于快速开发，需要深入理解原理或掌握更多技巧可阅读原著。</p><a id="more"></a><h1 id="控件"><a href="#控件" class="headerlink" title="控件"></a>控件</h1><p>Android 中所有的控件都具有<code>android:layout_width</code>和<code>android:layout_height</code>这两个属性。可选值：</p><ul><li>match_parent(fill_parent): 与父布局大小一样</li><li>wrap_content: 正好包住里面的内容</li></ul><h2 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;笔记基于&lt;a href=&quot;https://me.csdn.net/sinyu890807&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;郭霖大神&lt;/a&gt;所著的&lt;a href=&quot;https://blog.csdn.net/guolin_blog/article/details/52032038&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《第一行代码》第二版&lt;/a&gt;之第3章。该系列笔记主要目的在于快速开发，需要深入理解原理或掌握更多技巧可阅读原著。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://rootreturn0.github.io/categories/Android/"/>
    
    
      <category term="学习" scheme="http://rootreturn0.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>评论功能</title>
    <link href="http://rootreturn0.github.io/2019/10/19/%E8%AF%84%E8%AE%BA%E5%8A%9F%E8%83%BD/"/>
    <id>http://rootreturn0.github.io/2019/10/19/评论功能/</id>
    <published>2019-10-19T13:15:15.000Z</published>
    <updated>2019-10-19T13:22:36.202Z</updated>
    
    <content type="html"><![CDATA[<h1 id="主题配置文件"><a href="#主题配置文件" class="headerlink" title="主题配置文件"></a>主题配置文件</h1><p>🔗<a href="https://valine.js.org/" target="_blank" rel="noopener">官方文档</a></p><p>首先在<a href="https://leancloud.cn" target="_blank" rel="noopener">leancloud</a>注册一个账户，并创建一个应用。打开<code>yourblog</code>-&gt;<code>themes</code>-&gt;<code>next</code>-&gt;<code>_config.yml</code>，将获得的 appid 和 appkey 填入下方代码对应位置，enable 改为 true。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Valine.</span></span><br><span class="line"><span class="comment"># You can get your appid and appkey from https://leancloud.cn</span></span><br><span class="line"><span class="comment"># more info please open https://valine.js.org</span></span><br><span class="line"><span class="attr">valine:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  appid:</span> <span class="string">yourid</span></span><br><span class="line"><span class="attr">  appkey:</span> <span class="string">yourkey</span></span><br><span class="line"><span class="attr">  notify:</span> <span class="literal">false</span> <span class="comment"># mail notifier , https://github.com/xCss/Valine/wiki</span></span><br><span class="line"><span class="attr">  verify:</span> <span class="literal">false</span> <span class="comment"># Verification code</span></span><br><span class="line"><span class="attr">  placeholder:</span> <span class="string">Just</span> <span class="string">go</span> <span class="string">go</span> <span class="comment"># comment box placeholder</span></span><br><span class="line"><span class="attr">  avatar:</span> <span class="string">mm</span> <span class="comment"># gravatar style</span></span><br><span class="line"><span class="attr">  guest_info:</span> <span class="string">nick,mail,link</span> <span class="comment"># custom comment header</span></span><br><span class="line"><span class="attr">  pageSize:</span> <span class="number">10</span> <span class="comment"># pagination size</span></span><br></pre></td></tr></table></figure><h1 id="邮件推送"><a href="#邮件推送" class="headerlink" title="邮件推送"></a>邮件推送</h1><p>配置请参照<a href="https://cloud.tencent.com/developer/article/1142500" target="_blank" rel="noopener">作者文档</a></p>]]></content>
    
    <summary type="html">
    
      基于Valine在博文底部增加评论功能
    
    </summary>
    
      <category term="建站日志" scheme="http://rootreturn0.github.io/categories/%E5%BB%BA%E7%AB%99%E6%97%A5%E5%BF%97/"/>
    
    
      <category term="日志" scheme="http://rootreturn0.github.io/tags/%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>打赏功能</title>
    <link href="http://rootreturn0.github.io/2019/10/19/%E6%89%93%E8%B5%8F/"/>
    <id>http://rootreturn0.github.io/2019/10/19/打赏/</id>
    <published>2019-10-19T13:06:15.000Z</published>
    <updated>2019-10-19T13:14:51.160Z</updated>
    
    <content type="html"><![CDATA[<h1 id="主题配置文件"><a href="#主题配置文件" class="headerlink" title="主题配置文件"></a>主题配置文件</h1><p>next主题中内置了这一功能，打开主题配置文件，将如下部分注释取消：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Reward</span></span><br><span class="line"><span class="attr">reward_comment:</span> <span class="string">如果您喜欢这篇文章，可以请我喝杯咖啡～</span></span><br><span class="line"><span class="attr">wechatpay:</span> <span class="string">/images/wechatpay.png</span></span><br><span class="line"><span class="attr">alipay:</span> <span class="string">/images/alipay.png</span></span><br><span class="line"><span class="comment">#bitcoin: /images/bitcoin.png</span></span><br></pre></td></tr></table></figure><p>这里只用到了微信和支付宝。将收款码图片放入<code>yourblog</code>-&gt;<code>themes</code>-&gt;<code>next</code>-&gt;<code>source</code>-&gt;<code>images</code>，命名同上。</p><h1 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h1><p>如果直接采用从微信和支付宝保存下来的收款码，将会产生上下不对称的情况，且二者大小不一。这里采用了简单粗暴的处理办法：</p><ol><li>将图片要保留的内容裁剪成正方形。</li><li>打开<code>yourblog</code>-&gt;<code>themes</code>-&gt;<code>next</code>-&gt;<code>source</code>-&gt;<code>css</code>-&gt;<code>_common</code>-&gt;<code>components</code>-&gt;<code>post</code>-&gt;<code>post-reward.styl</code>，将里面的<code>#QR img</code>块改为以下内容：</li></ol><figure class="highlight styl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#QR</span> img&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">180px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">180px</span>;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden;</span><br><span class="line">    <span class="attribute">max-width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0.8em</span> <span class="number">2em</span> <span class="number">0</span> <span class="number">2em</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      在文章末尾增加打赏按钮
    
    </summary>
    
      <category term="建站日志" scheme="http://rootreturn0.github.io/categories/%E5%BB%BA%E7%AB%99%E6%97%A5%E5%BF%97/"/>
    
    
      <category term="日志" scheme="http://rootreturn0.github.io/tags/%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>上传本地图片</title>
    <link href="http://rootreturn0.github.io/2019/10/19/%E4%B8%8A%E4%BC%A0%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87/"/>
    <id>http://rootreturn0.github.io/2019/10/19/上传本地图片/</id>
    <published>2019-10-18T17:48:13.000Z</published>
    <updated>2019-10-18T17:55:45.562Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /d 你的hexo根目录</span><br><span class="line">npm install hexo-asset-image --save</span><br></pre></td></tr></table></figure><h1 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h1><p>打开根目录下的 <code>_config.yml</code> 文件，修改以下内容：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># URL</span></span><br><span class="line"><span class="comment">## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'</span></span><br><span class="line"><span class="attr">url:</span> <span class="attr">http://yourname.github.io</span></span><br></pre></td></tr></table></figure><h1 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h1><p>运行 <code>hexo n &quot;yourblogname&quot;</code> 生成博文时，/source/_posts 目录下会生成一个与 md 同名的文件夹，将图片放人该文件夹。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用![](yourblogname/picture.jpg)插入图片即可。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      在写blog时插入本地图片，并上传显示
    
    </summary>
    
      <category term="建站日志" scheme="http://rootreturn0.github.io/categories/%E5%BB%BA%E7%AB%99%E6%97%A5%E5%BF%97/"/>
    
    
      <category term="日志" scheme="http://rootreturn0.github.io/tags/%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>增加页面</title>
    <link href="http://rootreturn0.github.io/2019/10/19/%E5%A2%9E%E5%8A%A0%E9%A1%B5%E9%9D%A2/"/>
    <id>http://rootreturn0.github.io/2019/10/19/增加页面/</id>
    <published>2019-10-18T17:46:34.000Z</published>
    <updated>2019-10-18T17:57:34.098Z</updated>
    
    <content type="html"><![CDATA[<h1 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h1><p><a href="https://github.com/iissnan/hexo-theme-next/wiki/创建标签云页面" target="_blank" rel="noopener">🔗官方链接</a></p><p>新建一个页面</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page tags</span><br></pre></td></tr></table></figure><p>编辑新建界面，将页面类型设置为 tags ，主题将会在这个页面上显示标签云。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: Tags</span><br><span class="line">date: 2019-10-19 01:26:01</span><br><span class="line">type: "tags"</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>去除主题配置文件 <code>_config.yml</code> 中 tags 的注释。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line"><span class="attr">  home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">home</span></span><br><span class="line">  <span class="comment">#about: /about/ || user</span></span><br><span class="line"><span class="attr">  tags:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">tags</span></span><br><span class="line"><span class="attr">  categories:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">th</span></span><br><span class="line"><span class="attr">  archives:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">archive</span></span><br><span class="line">  <span class="comment">#schedule: /schedule/ || calendar</span></span><br><span class="line">  <span class="comment">#sitemap: /sitemap.xml || sitemap</span></span><br><span class="line">  <span class="comment">#commonweal: /404/ || heartbeat</span></span><br></pre></td></tr></table></figure><h2 id="标签的使用"><a href="#标签的使用" class="headerlink" title="标签的使用"></a>标签的使用</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tags: xxx</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tags:</span><br><span class="line"><span class="bullet">- </span>xxx</span><br><span class="line"><span class="bullet">- </span>xxx</span><br></pre></td></tr></table></figure><p>注意：使用第二种方式时，为并列标签，无等级区分。</p><h1 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h1><p><a href="https://github.com/iissnan/hexo-theme-next/wiki/创建分类页面" target="_blank" rel="noopener">🔗官方链接</a></p><p>新建一个页面</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page categories</span><br></pre></td></tr></table></figure><p>编辑新建界面，将页面类型设置为 categories ，主题将会在这个页面上显示所有的分类。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: Categories</span><br><span class="line">date: 2019-10-19 01:26:08</span><br><span class="line">type: "categories"</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>去除主题配置文件 <code>_config.yml</code> 中 categories 的注释。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line"><span class="attr">  home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">home</span></span><br><span class="line">  <span class="comment">#about: /about/ || user</span></span><br><span class="line"><span class="attr">  tags:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">tags</span></span><br><span class="line"><span class="attr">  categories:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">th</span></span><br><span class="line"><span class="attr">  archives:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">archive</span></span><br><span class="line">  <span class="comment">#schedule: /schedule/ || calendar</span></span><br><span class="line">  <span class="comment">#sitemap: /sitemap.xml || sitemap</span></span><br><span class="line">  <span class="comment">#commonweal: /404/ || heartbeat</span></span><br></pre></td></tr></table></figure><h2 id="分类的使用"><a href="#分类的使用" class="headerlink" title="分类的使用"></a>分类的使用</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">categories: xxx</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">categories:</span><br><span class="line"><span class="bullet">- </span>xxx</span><br><span class="line"><span class="bullet">- </span>xxx</span><br></pre></td></tr></table></figure><p>注意：使用第二种方式时，并非并列分类，而是分级分类。其中越靠前的越高级。</p>]]></content>
    
    <summary type="html">
    
      新建界面，解决跳转tags等404问题
    
    </summary>
    
      <category term="建站日志" scheme="http://rootreturn0.github.io/categories/%E5%BB%BA%E7%AB%99%E6%97%A5%E5%BF%97/"/>
    
    
      <category term="日志" scheme="http://rootreturn0.github.io/tags/%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>Android学习笔记_Activity</title>
    <link href="http://rootreturn0.github.io/2019/10/18/Android%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Activity/"/>
    <id>http://rootreturn0.github.io/2019/10/18/Android学习笔记-Activity/</id>
    <published>2019-10-18T14:07:48.000Z</published>
    <updated>2020-04-07T07:14:25.997Z</updated>
    
    <content type="html"><![CDATA[<p>笔记基于<a href="https://me.csdn.net/sinyu890807" target="_blank" rel="noopener">郭霖大神</a>所著的<a href="https://blog.csdn.net/guolin_blog/article/details/52032038" target="_blank" rel="noopener">《第一行代码》第二版</a>之第2章。该系列笔记主要目的在于快速开发，需要深入理解原理或掌握更多技巧可阅读原著。</p><p>其中：</p><ul><li>使用的IDE：Android Studio</li><li>示例项目名：ActivityTest</li><li>包名：“com.example.avtivitytest”</li></ul><a id="more"></a><h1 id="手动创建活动"><a href="#手动创建活动" class="headerlink" title="手动创建活动"></a>手动创建活动</h1><p><em>新建项目时选择<code>Add No Activity</code></em></p><center><img src="//rootreturn0.github.io/2019/10/18/Android学习笔记-Activity/初始项目结构.png" width="400" hegiht="600" align="center"><p>初始文件结构</p></center><p>右击<code>com.example.activitytest</code>包-&gt;<code>New</code>-&gt;<code>Activity</code>-&gt;<code>Empty Activity</code>，会弹出对话框，其中 Generate LayoutFile 会在<code>app/src/main/res</code>目录中为该活动自动生成对应的 layout 的 xml 文件；Launcher Activity 会将该活动设置为程序运行时首先加载的活动，即当前项目的主活动。</p><h1 id="创建和加载布局"><a href="#创建和加载布局" class="headerlink" title="创建和加载布局"></a>创建和加载布局</h1><p>右击<code>app/src/main/res</code>目录-&gt;<code>New</code>-&gt;<code>Directory</code>，可创建一个名为 layout 的目录，而后右击该目录，即可新建布局文件。</p><h2 id="添加按钮"><a href="#添加按钮" class="headerlink" title="添加按钮"></a>添加按钮</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">"vertical"</span> <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/button_1"</span> // 定义<span class="attr">id</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span> // 表示和父元素一样宽</span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span> // 表示当前元素的高度恰好包含里面内容</span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">"Button_1"</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.activitytest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        <span class="comment">// 本行将layout的id传入，为当前活动加载布局</span></span><br><span class="line">        setContentView(R.layout.thirt_layout); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="在AndroidManifest文件注册"><a href="#在AndroidManifest文件注册" class="headerlink" title="在AndroidManifest文件注册"></a>在AndroidManifest文件注册</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">package</span>=<span class="string">"com.example.activitytest"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">application</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:allowBackup</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:icon</span>=<span class="string">"@mipmap/ic_launcher"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:label</span>=<span class="string">"@string/app_name"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:roundIcon</span>=<span class="string">"@mipmap/ic_launcher_round"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:supportsRtl</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:theme</span>=<span class="string">"@style/AppTheme"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:name</span>=<span class="string">".FirstActivity"</span> // 指定注册活动 </span></span><br><span class="line"><span class="tag">            <span class="attr">android:label</span>=<span class="string">"This is FirstActivity"</span> &gt;</span> // 指定活动标题栏内容</span><br><span class="line">            <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">            // 以下两行将活动配置为主活动</span><br><span class="line">                <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.MAIN"</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.LAUNCHER"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Toast及按钮响应"><a href="#Toast及按钮响应" class="headerlink" title="Toast及按钮响应"></a>Toast及按钮响应</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.first_layout);</span><br><span class="line">    Button button1 = (Button) findViewById(R.id.button_1);</span><br><span class="line">    button1.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">            Toast.makeText(FirstActivity.<span class="keyword">this</span>, <span class="string">"You clicked Button_1!"</span>,</span><br><span class="line">                    Toast.LENGTH_SHORT).show();            &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 findViewById() 方法获取到布局文件中定义的元素，这里传入 R.id.button_1 来得到按钮的实例，而后注册监听器。</p><p>Toast 中 makeText 有三个参数，第一个是 Context（活动是一种上下文），第二个参数是 Toast 显示的文本内容，第三个是持续时长。注意，只有加上后面的 .show() ，Toast 才会显示。</p><h2 id="Menu"><a href="#Menu" class="headerlink" title="Menu"></a>Menu</h2><p>使用 Android 提供的方式创建菜单。菜单通过应用右上角的三个点的小按钮，以列表形式显示。</p><h3 id="创建菜单"><a href="#创建菜单" class="headerlink" title="创建菜单"></a>创建菜单</h3><p>右击<code>app/src/main/res</code>目录-&gt;<code>New</code>-&gt;<code>Directory</code>，创建名为 menu 的文件夹，并在文件夹下创建一个名为 main 的菜单文件（右击<code>menu</code>-&gt;<code>New</code>-&gt;<code>Menu resource file</code>）。</p><p>在<code>main.xml</code>添加如下代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">menu</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:id</span>=<span class="string">"@+id/add_item"</span>// 标识符</span></span><br><span class="line"><span class="tag">        <span class="attr">android:title</span>=<span class="string">"Add"</span> // 名称</span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:id</span>=<span class="string">"@+id/remove_item"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:title</span>=<span class="string">"Remove"</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">menu</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其中<code>item</code>标签用来创建具体的菜单项。</p><p>而后在<code>FirstActivity</code>中重写函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onCreateOptionsMenu</span><span class="params">(Menu menu)</span></span>&#123;</span><br><span class="line"><span class="comment">// 第一个参数为资源文件，第二个指定添加到的Menu对象</span></span><br><span class="line">    getMenuInflater().inflate(R.menu.main, menu); </span><br><span class="line">    <span class="comment">// 表示是否允许显示菜单</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="菜单响应"><a href="#菜单响应" class="headerlink" title="菜单响应"></a>菜单响应</h3><p>在<code>FirstActivity</code>中重写函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onOptionsItemSelected</span><span class="params">(@NonNull MenuItem item)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 判断点击的菜单项</span></span><br><span class="line">    <span class="keyword">switch</span> (item.getItemId())&#123;</span><br><span class="line">        <span class="keyword">case</span> R.id.add_item:</span><br><span class="line">            Toast.makeText(<span class="keyword">this</span>,<span class="string">"You clicked Add"</span>,Toast.LENGTH_SHORT).show();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> R.id.remove_item:</span><br><span class="line">            Toast.makeText(<span class="keyword">this</span>,<span class="string">"You clicked Remove"</span>,Toast.LENGTH_LONG).show();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.onOptionsItemSelected(item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="销毁活动"><a href="#销毁活动" class="headerlink" title="销毁活动"></a>销毁活动</h2><p>在模拟器中按下 Back 键，或调用<code>finish()</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.first_layout);</span><br><span class="line">    Button button1 = (Button) findViewById(R.id.button_1);</span><br><span class="line">    button1.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">            finish()            &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="使用Intent切换活动"><a href="#使用Intent切换活动" class="headerlink" title="使用Intent切换活动"></a>使用Intent切换活动</h1><h2 id="显式Intent"><a href="#显式Intent" class="headerlink" title="显式Intent"></a>显式Intent</h2><p>创建第二个活动，名为 SecondActivity。</p><p>修改<code>FirstActivity</code>中的按钮点击事件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.first_layout);</span><br><span class="line">    Button button1 = (Button) findViewById(R.id.button_1);</span><br><span class="line">    button1.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 传入 FirstActivity.this 作为上下文，SecondActivity.class为目标活动</span></span><br><span class="line">            Intent intent = <span class="keyword">new</span> Intent(FirstActivity.<span class="keyword">this</span>,SecondActivity.class);</span><br><span class="line">            startActivity(intent);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="隐式Intent"><a href="#隐式Intent" class="headerlink" title="隐式Intent"></a>隐式Intent</h2><p>通过<code>AndroidManifest.xml</code>中的<code>activity</code>标签下配置<code>&lt;intent-filter&gt;</code>内容，可以指定当前活动能够响应的 action 和 category。只有<code>&lt;action&gt;</code>和<code>&lt;category&gt;</code>中的内容能够同时匹配 Intent 指定的内容时，活动才能响应。</p><p>代码如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">".SecondActivity"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"com.example.activitytest.ACTION_START"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.DEFAULT"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br></pre></td></tr></table></figure><p>修改<code>FirstActivity</code>中的按钮点击事件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.first_layout);</span><br><span class="line">    Button button1 = (Button) findViewById(R.id.button_1);</span><br><span class="line">    button1.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">            Intent intent = <span class="keyword">new</span> Intent(<span class="string">"com.example.activitytest.ACTION_START"</span>);</span><br><span class="line">            startActivity(intent);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="增加Category"><a href="#增加Category" class="headerlink" title="增加Category"></a>增加Category</h3><p>在<code>AndroidManifest</code>中配置如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">".SecondActivity"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"com.example.activitytest.ACTION_START"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.DEFAULT"</span> /&gt;</span></span><br><span class="line">        // 不添加下行代码将导致程序崩溃</span><br><span class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"com.example.activitytest.MY_CATEGORY"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br></pre></td></tr></table></figure><p>修改<code>FirstActivity</code>中的按钮点击事件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.first_layout);</span><br><span class="line">    Button button1 = (Button) findViewById(R.id.button_1);</span><br><span class="line">    button1.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">            Intent intent = <span class="keyword">new</span> Intent(<span class="string">"com.example.activitytest.ACTION_START"</span>);</span><br><span class="line">            intent.addCategory(<span class="string">"com.example.activitytest.MY_CATEGORY"</span>);</span><br><span class="line">            startActivity(intent);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="其他Intent用法"><a href="#其他Intent用法" class="headerlink" title="其他Intent用法"></a>其他Intent用法</h2><h3 id="启动其他应用程序"><a href="#启动其他应用程序" class="headerlink" title="启动其他应用程序"></a>启动其他应用程序</h3><p>修改<code>FirstActivity</code>中的按钮点击事件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.first_layout);</span><br><span class="line">    Button button1 = (Button) findViewById(R.id.button_1);</span><br><span class="line">    button1.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">            Intent intent = <span class="keyword">new</span> Intent(Intent.ACTION_VIEW);</span><br><span class="line">            <span class="comment">// 注意：“http://” 不能省略</span></span><br><span class="line">            intent.setData(Uri.parse(<span class="string">"http://ww.baidu.com"</span>));</span><br><span class="line">            startActivity(intent);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时点击按钮可跳转至浏览器打开 “<a href="http://www.baidu.com&quot;。" target="_blank" rel="noopener">www.baidu.com&quot;。</a></p><p>在<code>AndroidManifest</code>中的<code>&lt;intent-filter&gt;</code>标签配置<code>&lt;data&gt;</code>标签，可指定活动能够响应的类型数据。<code>&lt;data&gt;</code>标签主要可配置以下内容：</p><ul><li>android:scheme 协议，如 http</li><li>android:host 主机名</li><li>android:port 端口</li><li>android:path 以上之后的部分</li><li>android:mimeType 可处理的数据类型</li></ul><p>示例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">".ThirdActivity"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.VIEW"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.DEFAULT"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:scheme</span>=<span class="string">"http"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当前活动能够响应的 action 是 Intent.ACTION_VIEW 的常量值，数据协议必须是 http。在点击按钮后，该活动也能响应Intent：</p><center><img src="//rootreturn0.github.io/2019/10/18/Android学习笔记-Activity/选择响应Intent的程序.png" width="400" hegiht="600" align="center"><p>选择响应Intent的程序</p></center><p><strong>从用户体验的角度来看，如果活动本身不具备加载并显示的网页的功能，千万不要这么用啊！！！</strong></p><p>除 http 协议外，还有许多 Uri 协议，常用的 Uri 协议见 <a href="https://blog.csdn.net/sinat_38239454/article/details/78937999" target="_blank" rel="noopener">&lt;&lt;Android 常用URI 值得记住&gt;&gt;</a>。</p><h2 id="传递数据"><a href="#传递数据" class="headerlink" title="传递数据"></a>传递数据</h2><p>Intent 中提供了一系列 <code>putExtra()</code> 方法的重载，可以将想要传递的数据暂存在 Intent 中。当启动另一个 Intent 后，只需要把这些数据再从 Intent 中取出即可。</p><h3 id="向下一个活动传递数据"><a href="#向下一个活动传递数据" class="headerlink" title="向下一个活动传递数据"></a>向下一个活动传递数据</h3><p>假设 FirstActivity 中有一个字符串，现在想把这个字符串传递到 SecondActivity 中，可以这样编写代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">button1.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">        String data = <span class="string">"Hello SecondActivity"</span>;</span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent(FirstActivity.<span class="keyword">this</span>,SecondActivity.class);</span><br><span class="line">        <span class="comment">// 第一个参数是键，用于之后取值；第二个参数为要传递的数据</span></span><br><span class="line">        intent.putExtra(<span class="string">"extra_data"</span>,data);</span><br><span class="line">        startActivity(intent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>SecondActivity 中接收代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecondActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_second);</span><br><span class="line">        <span class="comment">// 获取用于启动 SecondActivity 的Intent</span></span><br><span class="line">        Intent intent = getIntent();</span><br><span class="line">        <span class="comment">/** </span></span><br><span class="line"><span class="comment">         * getStringExtra() 获取字符串数据；</span></span><br><span class="line"><span class="comment">         * 如果是整型数据则用 getIntExtra()；</span></span><br><span class="line"><span class="comment">         * 如果是布尔数据则用 getBooleanExtra()；</span></span><br><span class="line"><span class="comment">         * 以此类推。</span></span><br><span class="line"><span class="comment">         * /</span></span><br><span class="line"><span class="comment">        String data = intent.getStringExtra("extra_data");</span></span><br><span class="line"><span class="comment">        Log.d("SecondActivity",data);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="返回数据给上一个活动"><a href="#返回数据给上一个活动" class="headerlink" title="返回数据给上一个活动"></a>返回数据给上一个活动</h3><p>Activity 中还有一个<code>startActivityForResult()</code>方法也可以启动活动。顾名思义，这个方法期望在活动销毁时能过返回结果给<strong>上一个活动</strong>。要想返回数据，则需要使用这个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">button1.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent(FirstActivity.<span class="keyword">this</span>,SecondActivity.class);</span><br><span class="line">        intent.putExtra(<span class="string">"extra_data"</span>,data);</span><br><span class="line">        <span class="comment">/** </span></span><br><span class="line"><span class="comment">         * 第一个参数是intent；</span></span><br><span class="line"><span class="comment">         * 第二个参数是请求码，用于在之后的回调中判断数据的来源，</span></span><br><span class="line"><span class="comment">         * 请求码只要是一个唯一值就行。</span></span><br><span class="line"><span class="comment">         * /</span></span><br><span class="line"><span class="comment">        startActivityForResult(intent, 1);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;);</span></span><br></pre></td></tr></table></figure><p>在<strong>下一个活动</strong>中使用如下代码：</p><ul><li>按下按钮返回时</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">button2.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">        intent.putExtra(<span class="string">"data_return"</span>,<span class="string">"Hello FirstActivity"</span>);</span><br><span class="line">        setResult(RESULT_OK,intent);</span><br><span class="line">        finish();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>按下 Back 键返回时</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onBackPressed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">intent.putExtra(<span class="string">"data_return"</span>,<span class="string">"Hello FirstActivity"</span>);</span><br><span class="line">setResult(RESULT_OK, intent);</span><br><span class="line">finish();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>setResult</code>十分重要，是专门用于向上一个活动返回数据的。第一个参数用于向上一个活动返回处理结果，一般只使用 RESULT_OK 或 RESULT_CANCELED 这两个值，第二个参数则把带有数据的Intent传递回去。</p><p>当使用<code>startActivityForResult()</code>方法启动下一个活动时，在下一个活动被销毁会回调上一个活动的<code>onActivityResult</code>方法，因此需要<strong>在上一个活动重写<code>onActivityResult</code>方法</strong> 来获取数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onActivityResult</span><span class="params">(<span class="keyword">int</span> requestCode, <span class="keyword">int</span> resultCode, Intent data)</span></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (requestCode)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">if</span> (resultCode==RESULT_OK)&#123;</span><br><span class="line">                String returnedData=data.getStringExtra(<span class="string">"data_return"</span>);</span><br><span class="line">                Log.d(<span class="string">"FirstActivity"</span>, returnedData);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个参数为启动活动时传入的请求码，第二个参数为返回数据时传入的处理结果，第三个参数为携带着返回数据的 Intent。由于实际使用时可能启动不止一个活动，故使用 requestCode 来确定传回的活动，resultCode 来判断处理结果是否成功，最后从 data 取值。</p><h1 id="活动的生命周期与临时数据"><a href="#活动的生命周期与临时数据" class="headerlink" title="活动的生命周期与临时数据"></a>活动的生命周期与临时数据</h1><h2 id="活动的生存期"><a href="#活动的生存期" class="headerlink" title="活动的生存期"></a>活动的生存期</h2><center><img src="//rootreturn0.github.io/2019/10/18/Android学习笔记-Activity/活动的生存期.png" width="400" hegiht="600" align="center"><p>活动的七大生存期</p></center><h2 id="保存活动的临时数据"><a href="#保存活动的临时数据" class="headerlink" title="保存活动的临时数据"></a>保存活动的临时数据</h2><p>当内存不足或由于其他什么原因导致活动被回收时，活动中的临时数据就可能消失，影响用户体验或程序管理。以下介绍在活动被销毁后重新创建保留数据的方法：</p><h3 id="保存"><a href="#保存" class="headerlink" title="保存"></a>保存</h3><p>Activity 中提供了名为<code>onSaveInstanceState()</code>的回调方法，这个方法保证活动在被回收之前一定会被调用。方法中携带的 Bundle 类型的参数提供了<code>putString()</code>和<code>putInt()</code>等方法保存数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onSaveInstanceState</span><span class="params">(Bundle outState)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>.onSaveInstanceState(outState);</span><br><span class="line">String tempData = <span class="string">"Something you just typed"</span>;</span><br><span class="line">outState.putString(<span class="string">"data_key"</span>, tempData);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="恢复数据"><a href="#恢复数据" class="headerlink" title="恢复数据"></a>恢复数据</h3><p><code>onCreate()</code>方法本身带有 Bundle 类型的参数。如果活动被回收前保存过数据，则这个参数不会为<code>null</code>，而是带有之前的数据。因此，通过这个参数可以取出之前保存的数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">setContentView(R.layout.activity_main);</span><br><span class="line"><span class="comment">// 如果保存过数据</span></span><br><span class="line"><span class="keyword">if</span> (savedInstanceState != <span class="keyword">null</span>) &#123;</span><br><span class="line">String tempData = savedInstanceState.getString(<span class="string">"data_key"</span>);</span><br><span class="line">&#125;</span><br><span class="line">···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>Tips：Intent可以结合Bundle一起传递数据。如：数据-&gt;Bundle-&gt;Intent。</em></p><h1 id="活动的启动模式"><a href="#活动的启动模式" class="headerlink" title="活动的启动模式"></a>活动的启动模式</h1><p>活动的启动模式一共有4种：standard、singleTop、singleTask和singleInstance。可以在 <code>AndroidManifest.xml</code>中通过给<code>&lt;activity&gt;</code>标签指定<code>android:launchMode</code>来选择启动模式。</p><h2 id="standard"><a href="#standard" class="headerlink" title="standard"></a>standard</h2><p>standard 是活动的默认启动模式。对于该模式的活动，系统在每次创建该活动时都会创建一个新的实例。</p><center><img src="//rootreturn0.github.io/2019/10/18/Android学习笔记-Activity/standard.png" width="400" hegiht="600" align="center"><p>standard 模式示意图</p></center><h2 id="singleTop"><a href="#singleTop" class="headerlink" title="singleTop"></a>singleTop</h2><p>对于该模式的活动，若该活动已处于活动栈的栈顶，则系统认为可以直接使用，不会创建一个新的实例；否则系统将会创建一个新实例。</p><center><img src="//rootreturn0.github.io/2019/10/18/Android学习笔记-Activity/singleTop.png" width="400" hegiht="600" align="center"><p>singleTop 模式示意图</p></center><h2 id="singleTask"><a href="#singleTask" class="headerlink" title="singleTask"></a>singleTask</h2><p>对于该模式的活动，若该活动已存在于活动的返回栈中，则系统直接使用，并把在这个活动之上的所有活动统统出栈，不会创建一个新的实例；否则系统将会创建一个新实例。</p><center><img src="//rootreturn0.github.io/2019/10/18/Android学习笔记-Activity/singleTask.png" width="400" hegiht="600" align="center"><p>singleTask 模式示意图</p></center><h2 id="singleInstance"><a href="#singleInstance" class="headerlink" title="singleInstance"></a>singleInstance</h2><p>对于该模式的活动，会有一个单独的返回栈来管理这个活动，所有的应用程序都将共用该返回栈。该模式可解决不同应用程序间共享活动实例的问题。</p><center><img src="//rootreturn0.github.io/2019/10/18/Android学习笔记-Activity/singleInstance.png" width="400" hegiht="600" align="center"><p>singleInstance 模式示意图</p></center>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;笔记基于&lt;a href=&quot;https://me.csdn.net/sinyu890807&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;郭霖大神&lt;/a&gt;所著的&lt;a href=&quot;https://blog.csdn.net/guolin_blog/article/details/52032038&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《第一行代码》第二版&lt;/a&gt;之第2章。该系列笔记主要目的在于快速开发，需要深入理解原理或掌握更多技巧可阅读原著。&lt;/p&gt;
&lt;p&gt;其中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用的IDE：Android Studio&lt;/li&gt;
&lt;li&gt;示例项目名：ActivityTest&lt;/li&gt;
&lt;li&gt;包名：“com.example.avtivitytest”&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Android" scheme="http://rootreturn0.github.io/categories/Android/"/>
    
    
      <category term="学习" scheme="http://rootreturn0.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Haydn</title>
    <link href="http://rootreturn0.github.io/2019/10/08/Haydn/"/>
    <id>http://rootreturn0.github.io/2019/10/08/Haydn/</id>
    <published>2019-10-07T18:12:49.000Z</published>
    <updated>2019-10-18T17:10:41.363Z</updated>
    
    <content type="html"><![CDATA[<p>有时并非欢快地跳跃着的。</p><p>但却依旧舒缓人疲惫的心灵。</p><p>非山河壮阔，</p><p>非人间星火，</p><p>非天外飞仙。</p><p>而是流淌在春天的生死明灭。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;有时并非欢快地跳跃着的。&lt;/p&gt;
&lt;p&gt;但却依旧舒缓人疲惫的心灵。&lt;/p&gt;
&lt;p&gt;非山河壮阔，&lt;/p&gt;
&lt;p&gt;非人间星火，&lt;/p&gt;
&lt;p&gt;非天外飞仙。&lt;/p&gt;
&lt;p&gt;而是流淌在春天的生死明灭。&lt;/p&gt;

      
    
    </summary>
    
      <category term="Me" scheme="http://rootreturn0.github.io/categories/Me/"/>
    
    
      <category term="随笔" scheme="http://rootreturn0.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>H</title>
    <link href="http://rootreturn0.github.io/2019/10/07/H/"/>
    <id>http://rootreturn0.github.io/2019/10/07/H/</id>
    <published>2019-10-07T09:33:27.000Z</published>
    <updated>2019-10-18T17:56:40.503Z</updated>
    
    <content type="html"><![CDATA[<script src="https://ajax.aspnetcdn.com/ajax/jQuery/jquery-3.4.1.min.js"></script><div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="请输入密码。" />    <label for="pass">请输入密码。</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      A normal dream
    
    </summary>
    
      <category term="Me" scheme="http://rootreturn0.github.io/categories/Me/"/>
    
    
      <category term="随笔" scheme="http://rootreturn0.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>R</title>
    <link href="http://rootreturn0.github.io/2019/10/07/C/"/>
    <id>http://rootreturn0.github.io/2019/10/07/C/</id>
    <published>2019-10-07T09:28:19.000Z</published>
    <updated>2019-10-18T17:10:32.520Z</updated>
    
    <content type="html"><![CDATA[<p>在曾经最低谷的时候（极小值），</p><p>她激励了我；</p><p>在现在最底谷的时候（极小值），</p><p>她安慰了我。</p><br><p>果然是我生命中重要的一个人（笑</p><br><p><strong><em>CAUSE AND CONSEQUENCE</em></strong></p>]]></content>
    
    <summary type="html">
    
      Important one.
    
    </summary>
    
      <category term="Me" scheme="http://rootreturn0.github.io/categories/Me/"/>
    
    
      <category term="随笔" scheme="http://rootreturn0.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>知足常乐</title>
    <link href="http://rootreturn0.github.io/2019/10/07/About%20Alessa0/"/>
    <id>http://rootreturn0.github.io/2019/10/07/About Alessa0/</id>
    <published>2019-10-06T17:42:10.000Z</published>
    <updated>2019-10-18T17:16:31.144Z</updated>
    
    <content type="html"><![CDATA[<script src="https://ajax.aspnetcdn.com/ajax/jQuery/jquery-3.4.1.min.js"></script><div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="English & You" />    <label for="pass">English & You</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      Compare
    
    </summary>
    
      <category term="Me" scheme="http://rootreturn0.github.io/categories/Me/"/>
    
    
      <category term="随笔" scheme="http://rootreturn0.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>Soul-like</title>
    <link href="http://rootreturn0.github.io/2019/10/06/soul-like/"/>
    <id>http://rootreturn0.github.io/2019/10/06/soul-like/</id>
    <published>2019-10-05T16:24:23.000Z</published>
    <updated>2019-10-18T17:09:49.729Z</updated>
    
    <content type="html"><![CDATA[<script src="https://ajax.aspnetcdn.com/ajax/jQuery/jquery-3.4.1.min.js"></script><div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="请输入密码。" />    <label for="pass">请输入密码。</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">U2FsdGVkX19sMGpM1F9NtMhj5ND+J2IX+wxJmeowVg5gNyiJZUyNpozvN+3CtnIKH2wM1EFGlhyiEYV3tlHaG9JRr6KXIKjcI/j0cHnXaxwN2fcp/5PtEXW6tOogpLggEd2OGpJp5Vq53ivpne8V/ks+bcKNbYlkiO2Fy0w5C4k8ZhT9Hn7tv1n5mJt/nDxreKCNDYOBrtrWwY3XaIWknz92/gkXRYQWrt3pfRKKZUooHCLvppPoQAxluX0OfhhCFl6NCH8CJRIW2dXd7I1D7xd/0czvXYtiSpWJdKPt8X0fl1xNLwqLw2NBl/nnCR+26mdxvU5M2rm2uvs5hKOtIxMMcbqjE/tOFORTFwUEDhtVE1bc7Hq+scWeik/1zZInJThJvxaFcxJz1jTgPWSqQrf9ZR5KVwKpeHxHYHQt0vPum1HyJDIar6Y80PxfwHHWlDpUtoMD5ZvaH8Kh7FX0NT4QORCmIeaSa2xxe3wFP3ZOtyYrWYN16spVIzYC26Ia1VlrqRbBJzr3F5//+xDGOibwUcWXrpv6znfb9J/sfhFH4tV1UY59fjGKndJnRDW/BDAo+UBTO9sgCKRQzj3Yv0+9Xj08oWE8+Bwxea/RmXoh/xfqq6HCK2haInFc8+iUu/+14Sc64T+Y0qx9aDAMGMHxHP7fGlSmP6HL5TzOMbHrjIe273lu2F/cdHnsdkmTzM8eBuFp7ffvHahcFp9j9A==</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      Ashen one
    
    </summary>
    
      <category term="Me" scheme="http://rootreturn0.github.io/categories/Me/"/>
    
    
      <category term="随笔" scheme="http://rootreturn0.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>xv6-调度</title>
    <link href="http://rootreturn0.github.io/2019/08/31/xv6-%E8%B0%83%E5%BA%A6/"/>
    <id>http://rootreturn0.github.io/2019/08/31/xv6-调度/</id>
    <published>2019-08-31T10:50:22.000Z</published>
    <updated>2019-10-18T17:14:32.392Z</updated>
    
    <content type="html"><![CDATA[<h2 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h2><p>由于可能同时有多个CPU请求进行调度，故需要进程表锁<code>ptable.lock</code>来避免竞争。</p><p>因此，进程在让出CPU前，必须要获得进程表锁，并释放其拥有的其他锁（避免同时持有多个锁导致死锁），修改自己的状态<code>proc-&gt;state</code>，然后进行调度。</p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>以下函数位于代码文件<code>proc.c</code>中。</p><h4 id="sched"><a href="#sched" class="headerlink" title="sched"></a>sched</h4><p>进程进入调度器，且必须持有进程表锁并改变进程状态。由于进程此时持有进程表锁，所以CPU应该是在关中断的情况下运行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">sched(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> intena;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> = <span class="title">myproc</span>();</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 未持有进程表锁，不应进入调度，引发内核错误</span></span><br><span class="line">  <span class="keyword">if</span>(!holding(&amp;ptable.lock))</span><br><span class="line">    panic(<span class="string">"sched ptable.lock"</span>);</span><br><span class="line">  <span class="comment">// 处于锁状态，不应进入调度，引发内核错误</span></span><br><span class="line">  <span class="keyword">if</span>(mycpu()-&gt;ncli != <span class="number">1</span>)</span><br><span class="line">    panic(<span class="string">"sched locks"</span>);</span><br><span class="line">  <span class="comment">// 进程处于运行态，不应进入调度，引发内核错误</span></span><br><span class="line">  <span class="keyword">if</span>(p-&gt;state == RUNNING)</span><br><span class="line">    panic(<span class="string">"sched running"</span>);</span><br><span class="line">  <span class="comment">// 开中断，不可执行mycpu()函数，不应进入调度，引发内核错误</span></span><br><span class="line">  <span class="keyword">if</span>(readeflags()&amp;FL_IF)</span><br><span class="line">    panic(<span class="string">"sched interruptible"</span>);</span><br><span class="line">  intena = mycpu()-&gt;intena; <span class="comment">// 暂存状态</span></span><br><span class="line">  swtch(&amp;p-&gt;context, mycpu()-&gt;scheduler); <span class="comment">// 保存当前上下文，并切换到之前保存的调度器的上下文，进入调度器</span></span><br><span class="line">  mycpu()-&gt;intena = intena; <span class="comment">// 恢复状态</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h4><p>在xv6中，使用时间片轮转法进行调度。当进程用完它的CPU时间片时，时钟中断会调用<code>yield</code>函数来让出CPU给新的进程，<code>yield</code>调用<code>sched</code>函数，<code>sched</code>调用<code>swtch</code>来切换都调度器线程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">yield(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  acquire(&amp;ptable.lock);  <span class="comment">//DOC: yieldlock 请求进程表锁</span></span><br><span class="line">  myproc()-&gt;state = RUNNABLE; <span class="comment">// 切换进程状态</span></span><br><span class="line">  sched(); </span><br><span class="line">  release(&amp;ptable.lock); <span class="comment">// 释放进程表锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="scheduler"><a href="#scheduler" class="headerlink" title="scheduler"></a>scheduler</h4><p>每个CPU在设置完成自己之后调用<code>scheduler</code>。</p><p>调度器<code>scheduler</code>永远不会返回，而是不断循环。循环步骤为：</p><ol><li>选择要运行的流程</li><li>swtch开始运行该过程</li><li>最终该过程通过swtch将控制转移回调度程序。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">scheduler(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">cpu</span> *<span class="title">c</span> = <span class="title">mycpu</span>();</span></span><br><span class="line">  c-&gt;proc = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 不断循环，永不停止</span></span><br><span class="line">  <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    <span class="comment">// 开中断，以允许I/O到达</span></span><br><span class="line">    sti();  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在进程表上不断循环，寻找进程并运行</span></span><br><span class="line">    acquire(&amp;ptable.lock); <span class="comment">// 请求进程表锁</span></span><br><span class="line">    <span class="keyword">for</span>(p = ptable.proc; p &lt; &amp;ptable.proc[NPROC]; p++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(p-&gt;state != RUNNABLE) <span class="comment">// 进程不可运行，转到下一个进程</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Switch to chosen process.  It is the process's job</span></span><br><span class="line">      <span class="comment">// to release ptable.lock and then reacquire it</span></span><br><span class="line">      <span class="comment">// before jumping back to us.</span></span><br><span class="line">      <span class="comment">// 切换到选定的进程</span></span><br><span class="line">      c-&gt;proc = p;</span><br><span class="line">      switchuvm(p); <span class="comment">// 切换到该进程的页表</span></span><br><span class="line">      p-&gt;state = RUNNING;</span><br><span class="line"></span><br><span class="line">      swtch(&amp;(c-&gt;scheduler), p-&gt;context); <span class="comment">// 切换到该进程运行</span></span><br><span class="line">      switchkvm(); <span class="comment">// 当没有进程正在运行时，将页表寄存器切换到仅内核页表。</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// Process is done running for now.</span></span><br><span class="line">      <span class="comment">// It should have changed its p-&gt;state before coming back.</span></span><br><span class="line">      <span class="comment">// 进程已结束运行，改变自身状态</span></span><br><span class="line">      c-&gt;proc = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    release(&amp;ptable.lock); <span class="comment">// 释放进程表锁，防止其他CPU无法进行调度</span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="锁与中断"><a href="#锁与中断" class="headerlink" title="锁与中断"></a>锁与中断</h3><h4 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h4><ul><li>为保证进程状态的上下文在运行<code>swtch</code>时保持不变：进程表锁由旧进程获得，新进程释放。</li><li>为防止其他CPU闲置时锁被当前CPU占有而无法调度，其他CPU上运行进程无法让出CPU，导致死锁的情况：在遍历一次进程表后总要释放锁。</li></ul><h4 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h4><ul><li>为防止所有进程都在等待I/O时关中断导致的I/O无法到达引发的死锁，调度器在每次循坏开始前进行开中断。</li></ul><h2 id="睡眠与唤醒"><a href="#睡眠与唤醒" class="headerlink" title="睡眠与唤醒"></a>睡眠与唤醒</h2><p>函数<code>sleep</code>和<code>wakeup</code>位于代码文件<code>proc.c</code>中。</p><p>使进程进入睡眠或进行唤醒均需要改变进程状态，故需要进程表锁以保证状态修改的原子性。其中函数<code>sleep</code>要在使进程进入睡眠前获取进程表锁，以保证在使函数进入睡眠时至少持有一个锁，防止<code>wakeup</code>在进程进入睡眠前被调用导致的死锁。当<code>sleep</code>本身持有的锁为进程表锁时，则略过请求这一步，防止死锁。</p><h2 id="可改进之处"><a href="#可改进之处" class="headerlink" title="可改进之处"></a>可改进之处</h2><h3 id="调度-1"><a href="#调度-1" class="headerlink" title="调度"></a>调度</h3><ul><li>轮转法无优先级的区分</li></ul><p>会导致高优先级的进程无法优先运行，可能导致系统运行时间的增加，影响使用者在实际使用时的体验。可使用其他较为复杂的算法，如高响应比优先算法等以改进体验。</p><h3 id="睡眠与唤醒-1"><a href="#睡眠与唤醒-1" class="headerlink" title="睡眠与唤醒"></a>睡眠与唤醒</h3><ul><li>唤醒需要遍历进程表</li></ul><p>在进程数量大的时候这种做法效率极低。使用另一个结构体来维护链表可大大提高效率。</p><ul><li>唤醒时会唤醒队列中全部进程</li></ul><p>大多数情况下，同一时间需要唤醒的进程在队列中是少数部分，许多仍需等待的进程将会被“莫名其妙”地唤醒并再度检查状态重新进入睡眠，导致操作系统需要处理许多新的不必要的任务。</p><p>唤醒时应分为个体唤醒（唤醒单个进程）和群体唤醒（唤醒所有进程），减少系统负担。</p>]]></content>
    
    <summary type="html">
    
      xv6操作系统之调度源码阅读与分析
    
    </summary>
    
      <category term="操作系统" scheme="http://rootreturn0.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="学习" scheme="http://rootreturn0.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>xv6-管道</title>
    <link href="http://rootreturn0.github.io/2019/08/31/xv6-%E7%AE%A1%E9%81%93/"/>
    <id>http://rootreturn0.github.io/2019/08/31/xv6-管道/</id>
    <published>2019-08-31T00:29:38.000Z</published>
    <updated>2019-10-18T17:14:24.466Z</updated>
    
    <content type="html"><![CDATA[<h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><p>从管道的一端写入数据字节，然后数据被拷贝到内核缓冲区中，接着进程就能从管道的另一端读取数据了。</p><p>在xv6中，管道使用被读取字节数<code>nread</code>和被写入字节数<code>nwrite</code>的差值判断管道状态：</p><ul><li>nwrite == nread 则数据未写入或被读取完毕，管道空</li><li>nwrite == nread + PIPESIZE 则管道满</li></ul><p>由于管道的读取与写入均需要使用<code>nread</code>和<code>nwrite</code>以获悉管道状态，故这两个计数参数不能在某一函数（写入/读取）清零，否则将影响另一函数（读取/写入）的执行。因此，xv6中使用<code>data[nread % PIPESIZE]</code>和<code>data[nwrite % PIPESIZE]</code>来控制读写时的管道数据偏移，即循环写/读，在<code>data[PIPESIZE-1]</code>后写入的数据存放在<code>data[0]</code>中。</p><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pipe</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span> <span class="comment">// 锁</span></span><br><span class="line">  <span class="keyword">char</span> data[PIPESIZE]; <span class="comment">// 管道数据</span></span><br><span class="line">  uint nread;     <span class="comment">// 被读取字节数，从缓冲区中读取</span></span><br><span class="line">  uint nwrite;    <span class="comment">// 被写入字节数，写入缓冲区</span></span><br><span class="line">  <span class="keyword">int</span> readopen;   <span class="comment">// 读文件描述符是否依旧处于open状态</span></span><br><span class="line">  <span class="keyword">int</span> writeopen;  <span class="comment">// 写文件描述符是否依旧处于open状态</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="管道函数"><a href="#管道函数" class="headerlink" title="管道函数"></a>管道函数</h3><p>以下分析管道读写函数，其他函数仅列出函数作用，详细注释见代码文件<code>pipe.c</code>。</p><h4 id="读写"><a href="#读写" class="headerlink" title="读写"></a>读写</h4><p>管道读写操作通过管道锁实现互斥，操作运行时必须持有管道锁。</p><p>管道数据写入时首先获取管道锁而后写入数据，若达到管道容量上限，则写操作唤醒读操作后进入睡眠等待并释放管道锁。此时读操作可获得请求的管道锁，在读取完数据后管道变空，则读操作唤醒写操作后进入睡眠等待并释放管道锁。而后管道写操作再次获得管道锁，循环往复直至数据传输完毕，其中最后一次传输可能未写满管道。</p><p>当使用管道的操作被杀后，管道读写操作都将终止；当管道不可读时，管道写操作将被终止。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 管道写</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">pipewrite(struct pipe *p, <span class="keyword">char</span> *addr, <span class="keyword">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">  acquire(&amp;p-&gt;lock); <span class="comment">// 请求获得管道锁，以保护计数器、数据以及相关不变量</span></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;nwrite == p-&gt;nread + PIPESIZE)&#123;  <span class="comment">// 管道满</span></span><br><span class="line">      <span class="comment">// 如果管道文件不可读或进程被杀，释放管道锁并终止管道写操作</span></span><br><span class="line">      <span class="keyword">if</span>(p-&gt;readopen == <span class="number">0</span> || myproc()-&gt;killed)&#123;</span><br><span class="line">        release(&amp;p-&gt;lock);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      wakeup(&amp;p-&gt;nread); <span class="comment">// 通知睡眠中的读者缓冲区中有数据可读</span></span><br><span class="line">      sleep(&amp;p-&gt;nwrite, &amp;p-&gt;lock);  <span class="comment">// 管道写操作进入睡眠等待（睡眠时将释放管道锁）</span></span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;data[p-&gt;nwrite++ % PIPESIZE] = addr[i]; <span class="comment">// 将所需读取的块内数据赋值给管道数据</span></span><br><span class="line">  &#125;</span><br><span class="line">  wakeup(&amp;p-&gt;nread);  <span class="comment">// 通知睡眠中的读者缓冲区中有数据可读</span></span><br><span class="line">  release(&amp;p-&gt;lock); <span class="comment">// 释放管道锁</span></span><br><span class="line">  <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//管道读</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">piperead(struct pipe *p, <span class="keyword">char</span> *addr, <span class="keyword">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">  acquire(&amp;p-&gt;lock); <span class="comment">// 请求获得管道锁，以保护计数器、数据以及相关不变量</span></span><br><span class="line">  <span class="keyword">while</span>(p-&gt;nread == p-&gt;nwrite &amp;&amp; p-&gt;writeopen)&#123;  <span class="comment">//DOC: 管道为空且管道可写，则管道读操作可进入睡眠</span></span><br><span class="line">    <span class="comment">// 进程被杀，释放管道锁，终止管道读操作</span></span><br><span class="line">    <span class="keyword">if</span>(myproc()-&gt;killed)&#123;</span><br><span class="line">      release(&amp;p-&gt;lock);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sleep(&amp;p-&gt;nread, &amp;p-&gt;lock); <span class="comment">//DOC: piperead-sleep 管道读操作进入睡眠等待（睡眠时将释放管道锁）</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n; i++)&#123;  <span class="comment">// 拷贝数据</span></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;nread == p-&gt;nwrite) <span class="comment">// 读取字节数等于写入字节数，表示读取完成</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    addr[i] = p-&gt;data[p-&gt;nread++ % PIPESIZE]; <span class="comment">// 将所需读取的管道数据赋值给块内数据</span></span><br><span class="line">  &#125;</span><br><span class="line">  wakeup(&amp;p-&gt;nwrite);  <span class="comment">// 通知睡眠中的写者缓冲区中可写</span></span><br><span class="line">  release(&amp;p-&gt;lock);</span><br><span class="line">  <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul><li>pipealloc 管道分配，并初始化管道。</li><li>pipeclose 管道关闭。若读写两方均关闭，则释放内存；否则关闭管道一端并唤醒另一方。当关闭写端时，仍可进行读操作，但将管道内剩余数据读完后，再次进行读操作便返回0，相当于读到文件末尾；当关闭读段时，写操作会在进行过程中中断。</li></ul>]]></content>
    
    <summary type="html">
    
      xv6操作系统之管道源码阅读与分析
    
    </summary>
    
      <category term="操作系统" scheme="http://rootreturn0.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="学习" scheme="http://rootreturn0.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>xv6-文件系统</title>
    <link href="http://rootreturn0.github.io/2019/08/31/xv6-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    <id>http://rootreturn0.github.io/2019/08/31/xv6-文件系统/</id>
    <published>2019-08-30T17:47:50.000Z</published>
    <updated>2019-10-18T17:14:13.038Z</updated>
    
    <content type="html"><![CDATA[<h2 id="文件系统总体设计"><a href="#文件系统总体设计" class="headerlink" title="文件系统总体设计"></a>文件系统总体设计</h2><h3 id="文件系统分层"><a href="#文件系统分层" class="headerlink" title="文件系统分层"></a>文件系统分层</h3><p><img src="https://th0ar.gitbooks.io/xv6-chinese/content/pic/f6-1.png" alt="文件系统层"></p><p>如图所示xv6的文件系统分6层实现：</p><ol><li>第一层（自下而上）通过块缓冲读写 IDE 硬盘，同步对磁盘的访问，且通过块的锁保证同一时间只有一个内核进程可以修改磁盘块；  </li><li>第二层使得更高层的接口可以将对磁盘的更新按会话打包，通过会话的方式来保证这些操作是原子操作。</li><li>第三层提供无名文件，每一个文件由一个inode和一连串的数据块组成。</li><li>第四层将目录实现为一种特殊的inode，内容是一连串的目录项，每一个目录项包含一个文件名和对应的inode。</li><li>第五层提供了层次路经名（如/xx/xxx），这一层通过递归的方式来查询路径对应的文件。</li><li>第六层将许多资源（如管道，设备，文件等）抽象为文件系统的接口，极大地简化了程序员的工作。</li></ol><h3 id="磁盘分层"><a href="#磁盘分层" class="headerlink" title="磁盘分层"></a>磁盘分层</h3><p>磁盘分层为引导块、超级块、日志块、inode块、空闲块位图和数据块等。  </p><p>文件系统不使用引导块；超级块包含了文件系统的元信息；日志块中的日志维护了文件系统操作的原子性，防止操作过程中引发的系统崩溃而导致的数据不同步；inode块用于存放inode（一个块可存放多个inode）；空闲块位图便于查找空闲的块；数据块中保存了文件和目录等内容。</p><h2 id="块缓冲层"><a href="#块缓冲层" class="headerlink" title="块缓冲层"></a>块缓冲层</h2><h3 id="需要实现的目标"><a href="#需要实现的目标" class="headerlink" title="需要实现的目标"></a>需要实现的目标</h3><ol><li>同步对磁盘的访问。对于任意一个块，同一时间仅有一份拷贝放在内存中且只允许一个内核线程对该拷贝进行修改。</li><li>缓存常用的块以减少磁盘读取次数，提高系统效率。</li></ol><h3 id="实现方案"><a href="#实现方案" class="headerlink" title="实现方案"></a>实现方案</h3><p>代码参见<code>bio.c</code>。</p><p>根据时间与空间局部性原理，将最近经常访问的磁盘块缓存在内存中，并使用LRU替换策略。</p><h4 id="结构定义"><a href="#结构定义" class="headerlink" title="结构定义"></a>结构定义</h4><p>xv6将缓冲区分为两种状态：</p><ol><li>B_VALID 意味着这个缓冲区拥有磁盘块的有效内容；</li><li>B_DIRTY 意味着缓冲区的内容已经被改变并且需要写回磁盘；</li></ol><p>与旧版相比，B_BUSY 状态在最新版代码中被删去。但由于缓存区中的块的锁的存在，只有持有锁才能访问该块，而在另一线程未使用完成前，该锁不会被释放，此时只能循环等待锁的释放，获得锁后方可获得块。故依旧可保持块内容的原子性。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 内存中的磁盘块结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buf</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> flags; <span class="comment">// 标记磁盘状态，valid/dirty</span></span><br><span class="line">  uint dev; <span class="comment">// 磁盘设备号</span></span><br><span class="line">  uint blockno; <span class="comment">// 块编号</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sleeplock</span> <span class="title">lock</span>;</span></span><br><span class="line">  uint refcnt; <span class="comment">// 引用计数</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">prev</span>;</span> <span class="comment">// LRU cache list 使用LRU替换</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">next</span>;</span> <span class="comment">// 链式结构连接磁盘块</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">qnext</span>;</span> <span class="comment">// 磁盘队列</span></span><br><span class="line">  uchar data[BSIZE]; <span class="comment">// 块大小为512字节</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 块缓冲区结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> <span class="title">buf</span>[<span class="title">NBUF</span>];</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通过 prev/next 连接所有缓冲块</span></span><br><span class="line">  <span class="comment">// 其中 head.next 是最近最常使用的块.</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> <span class="title">head</span>;</span></span><br><span class="line">&#125; bcache;</span><br></pre></td></tr></table></figure><h4 id="初始化-binit"><a href="#初始化-binit" class="headerlink" title="初始化 binit"></a>初始化 binit</h4><p>从一个静态数组<code>buf</code>中构建出一个有<code>NBUF</code>个元素的双向链表。所有对块缓冲的访问都通过链表而非静态数组。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">binit(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">b</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化块缓冲锁</span></span><br><span class="line">  initlock(&amp;bcache.lock, <span class="string">"bcache"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//PAGEBREAK!</span></span><br><span class="line">  <span class="comment">// 构建缓冲双向链表</span></span><br><span class="line">  bcache.head.prev = &amp;bcache.head;</span><br><span class="line">  bcache.head.next = &amp;bcache.head;</span><br><span class="line">  <span class="keyword">for</span>(b = bcache.buf; b &lt; bcache.buf+NBUF; b++)&#123;</span><br><span class="line">    b-&gt;next = bcache.head.next;</span><br><span class="line">    b-&gt;prev = &amp;bcache.head;</span><br><span class="line">    <span class="comment">// 初始化缓冲区中的块的锁</span></span><br><span class="line">    initsleeplock(&amp;b-&gt;lock, <span class="string">"buffer"</span>);</span><br><span class="line">    bcache.head.next-&gt;prev = b;</span><br><span class="line">    bcache.head.next = b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="查找-bget"><a href="#查找-bget" class="headerlink" title="查找 bget"></a>查找 bget</h4><p>扫描缓冲区链表，通过给定的设备号和扇区号找到对应的缓冲区。如果未找到，则分配一个缓冲区，否则返回一个持有锁的缓冲区。代码中在双向链表的搜索中向最近最常使用方向查找，若未找到则向另一方向查找空闲缓冲区以分配。</p><p>其中若找到缓冲区中指定的块，返回的结果也不一定是指定的块。因为在请求该块的锁前已释放缓冲区锁，若该块未持有锁且正在被用来缓冲另外一个块，则重新获得锁时已是另一个块。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">buf</span>*</span></span><br><span class="line"><span class="class"><span class="title">bget</span>(<span class="title">uint</span> <span class="title">dev</span>, <span class="title">uint</span> <span class="title">blockno</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">b</span>;</span></span><br><span class="line"></span><br><span class="line">  acquire(&amp;bcache.lock); <span class="comment">// 请求块缓冲区锁</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 不能保证 b 仍然是可用的缓冲区：它有可能被用来缓冲另外一个块。</span></span><br><span class="line">  <span class="keyword">for</span>(b = bcache.head.next; b != &amp;bcache.head; b = b-&gt;next)&#123;</span><br><span class="line">    <span class="keyword">if</span>(b-&gt;dev == dev &amp;&amp; b-&gt;blockno == blockno)&#123;</span><br><span class="line">      b-&gt;refcnt++; <span class="comment">// 引用计数加一</span></span><br><span class="line">      release(&amp;bcache.lock); <span class="comment">// 释放块缓冲区锁</span></span><br><span class="line">      acquiresleep(&amp;b-&gt;lock); <span class="comment">// 请求该块的锁</span></span><br><span class="line">      <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Not cached; recycle an unused buffer. 未找到则重新查找</span></span><br><span class="line">  <span class="comment">// Even if refcnt==0, B_DIRTY indicates a buffer is in use</span></span><br><span class="line">  <span class="comment">// because log.c has modified it but not yet committed it.</span></span><br><span class="line">  <span class="comment">// 即使refcnt等于0，也可通过B_DIRTY知道缓冲区被使用，此时日志已修改但未提交 </span></span><br><span class="line">  <span class="keyword">for</span>(b = bcache.head.prev; b != &amp;bcache.head; b = b-&gt;prev)&#123;</span><br><span class="line">    <span class="keyword">if</span>(b-&gt;refcnt == <span class="number">0</span> &amp;&amp; (b-&gt;flags &amp; B_DIRTY) == <span class="number">0</span>) &#123;</span><br><span class="line">      b-&gt;dev = dev;</span><br><span class="line">      b-&gt;blockno = blockno;</span><br><span class="line">      b-&gt;flags = <span class="number">0</span>;</span><br><span class="line">      b-&gt;refcnt = <span class="number">1</span>;</span><br><span class="line">      release(&amp;bcache.lock);</span><br><span class="line">      acquiresleep(&amp;b-&gt;lock);</span><br><span class="line">      <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 未找到块且未能分配块，引发内核错误</span></span><br><span class="line">  panic(<span class="string">"bget: no buffers"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="读-bread"><a href="#读-bread" class="headerlink" title="读 bread"></a>读 bread</h4><p><code>bread</code>会首先调用<code>bget</code>从缓存中去寻找块是否存在。如果存在直接返回；如果不存在则请求磁盘读操作，读到缓存中后再返回结果。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buf</span>*</span></span><br><span class="line"><span class="class"><span class="title">bread</span>(<span class="title">uint</span> <span class="title">dev</span>, <span class="title">uint</span> <span class="title">blockno</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">b</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取缓冲区</span></span><br><span class="line">  b = bget(dev, blockno);</span><br><span class="line">  <span class="comment">// 如果缓冲区中不存在指定的块，则从磁盘中读出</span></span><br><span class="line">  <span class="keyword">if</span>((b-&gt;flags &amp; B_VALID) == <span class="number">0</span>) &#123;</span><br><span class="line">    iderw(b);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="写-bwrite"><a href="#写-bwrite" class="headerlink" title="写 bwrite"></a>写 bwrite</h4><p>设置 B_DIRTY 位并且调用 iderw 将缓冲区的内容写到磁盘。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">bwrite(struct buf *b)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 该块未锁，可能已被释放，无法写入，引发内核错误</span></span><br><span class="line">  <span class="keyword">if</span>(!holdingsleep(&amp;b-&gt;lock))</span><br><span class="line">    panic(<span class="string">"bwrite"</span>);</span><br><span class="line">  b-&gt;flags |= B_DIRTY;</span><br><span class="line">  iderw(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="释放-brelse"><a href="#释放-brelse" class="headerlink" title="释放 brelse"></a>释放 brelse</h4><p>将一块缓冲区移动到链表的头部，唤醒睡眠在这块缓冲区上的进程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 唤醒睡眠在这块缓冲区上的进程；将一块缓冲区移动到链表的头部。</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">brelse(struct buf *b)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 缓冲区未持有块锁，引发内核错误</span></span><br><span class="line">  <span class="keyword">if</span>(!holdingsleep(&amp;b-&gt;lock))</span><br><span class="line">    panic(<span class="string">"brelse"</span>);</span><br><span class="line"></span><br><span class="line">  releasesleep(&amp;b-&gt;lock); <span class="comment">// 释放块锁</span></span><br><span class="line"></span><br><span class="line">  acquire(&amp;bcache.lock); <span class="comment">// 请求  缓冲区锁</span></span><br><span class="line">  b-&gt;refcnt--; <span class="comment">//引用计数减一</span></span><br><span class="line">  <span class="keyword">if</span> (b-&gt;refcnt == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 无进程等待使用，移动到链表头部</span></span><br><span class="line">    b-&gt;next-&gt;prev = b-&gt;prev;</span><br><span class="line">    b-&gt;prev-&gt;next = b-&gt;next;</span><br><span class="line">    b-&gt;next = bcache.head.next;</span><br><span class="line">    b-&gt;prev = &amp;bcache.head;</span><br><span class="line">    bcache.head.next-&gt;prev = b;</span><br><span class="line">    bcache.head.next = b;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  release(&amp;bcache.lock); <span class="comment">//释放缓冲区锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="日志层"><a href="#日志层" class="headerlink" title="日志层"></a>日志层</h3><p>每一个系统调用都可能包含一个必须从头到尾原子完成的写操作序列，称这样的一个序列为一个会话。任何时候只能有一个进程在一个会话之中，其他进程必须等待当前会话中的进程结束。因此同一时刻日志最多只记录一次会话。</p><p>该层用于维护系统崩溃后到原子性，即会话要么完成，要么系统恢复至会话开始前的状态。</p><h3 id="块分配器"><a href="#块分配器" class="headerlink" title="块分配器"></a>块分配器</h3><p>本部分涉及的函数位于<code>fs.c</code>。</p><p>由于<code>bread</code>与<code>brelse</code>已有锁进行互斥，块分配器无需再加锁。</p><h4 id="分配新的磁盘块"><a href="#分配新的磁盘块" class="headerlink" title="分配新的磁盘块"></a>分配新的磁盘块</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> uint</span><br><span class="line">balloc(uint dev)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> b, bi, m;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp</span>;</span></span><br><span class="line"></span><br><span class="line">  bp = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(b = <span class="number">0</span>; b &lt; sb.size; b += BPB)&#123; <span class="comment">// 读位图每一块</span></span><br><span class="line">    bp = bread(dev, BBLOCK(b, sb));</span><br><span class="line">    <span class="keyword">for</span>(bi = <span class="number">0</span>; bi &lt; BPB &amp;&amp; b + bi &lt; sb.size; bi++)&#123; <span class="comment">// 读块内每一位</span></span><br><span class="line">      m = <span class="number">1</span> &lt;&lt; (bi % <span class="number">8</span>);</span><br><span class="line">      <span class="keyword">if</span>((bp-&gt;data[bi/<span class="number">8</span>] &amp; m) == <span class="number">0</span>)&#123;  <span class="comment">// 判断块是否空闲</span></span><br><span class="line">        bp-&gt;data[bi/<span class="number">8</span>] |= m;  <span class="comment">// 将块标记为使用中</span></span><br><span class="line">        log_write(bp);</span><br><span class="line">        brelse(bp); <span class="comment">// 释放块</span></span><br><span class="line">        bzero(dev, b + bi); <span class="comment">// 清零块</span></span><br><span class="line">        <span class="keyword">return</span> b + bi;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    brelse(bp);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 超出块范围，引发错误</span></span><br><span class="line">  panic(<span class="string">"balloc: out of blocks"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="释放磁盘块"><a href="#释放磁盘块" class="headerlink" title="释放磁盘块"></a>释放磁盘块</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">bfree(<span class="keyword">int</span> dev, uint b)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp</span>;</span></span><br><span class="line">  <span class="keyword">int</span> bi, m;</span><br><span class="line"></span><br><span class="line">  readsb(dev, &amp;sb);</span><br><span class="line">  bp = bread(dev, BBLOCK(b, sb));</span><br><span class="line">  bi = b % BPB;</span><br><span class="line">  m = <span class="number">1</span> &lt;&lt; (bi % <span class="number">8</span>);</span><br><span class="line">  <span class="keyword">if</span>((bp-&gt;data[bi/<span class="number">8</span>] &amp; m) == <span class="number">0</span>) <span class="comment">// 释放空闲块，错误</span></span><br><span class="line">    panic(<span class="string">"freeing free block"</span>);</span><br><span class="line">  bp-&gt;data[bi/<span class="number">8</span>] &amp;= ~m;</span><br><span class="line">  log_write(bp);</span><br><span class="line">  brelse(bp); <span class="comment">// 释放块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="inode"><a href="#inode" class="headerlink" title="inode"></a>inode</h3><p>inode有两种类别：</p><ul><li><p>磁盘上的记录文件大小、数据块扇区号的数据结构</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dinode</span> &#123;</span></span><br><span class="line">  <span class="keyword">short</span> type;           <span class="comment">// 区分文件、目录和特殊文件的 i 节点，0表示为空闲节点</span></span><br><span class="line">  <span class="keyword">short</span> major;          <span class="comment">// 主设备号（仅限T_DEV）</span></span><br><span class="line">  <span class="keyword">short</span> minor;          <span class="comment">// 辅设备号（仅限T_DEV）</span></span><br><span class="line">  <span class="keyword">short</span> nlink;          <span class="comment">// 文件系统中的i节点连接数</span></span><br><span class="line">  uint size;            <span class="comment">// 文件的字节数</span></span><br><span class="line">  uint addrs[NDIRECT+<span class="number">1</span>]; <span class="comment">// 用于这个文件的数据块的块号</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>内存中的一个 i 节点，包含一个磁盘上 i 节点的拷贝，以及一些内核需要的附加信息</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> &#123;</span></span><br><span class="line">  uint dev;           <span class="comment">// Device number 设备号</span></span><br><span class="line">  uint inum;          <span class="comment">// Inode number inode号</span></span><br><span class="line">  <span class="keyword">int</span> ref;            <span class="comment">// Reference count 引用数</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sleeplock</span> <span class="title">lock</span>;</span> <span class="comment">// protects everything below here 保护以下所有数据</span></span><br><span class="line">  <span class="keyword">int</span> valid;          <span class="comment">// inode has been read from disk? i节点是否已从磁盘中读取</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 以下均为磁盘上的i节点，即dinode，的拷贝</span></span><br><span class="line">  <span class="keyword">short</span> type;         <span class="comment">// copy of disk inode</span></span><br><span class="line">  <span class="keyword">short</span> major;</span><br><span class="line">  <span class="keyword">short</span> minor;</span><br><span class="line">  <span class="keyword">short</span> nlink;</span><br><span class="line">  uint size;</span><br><span class="line">  uint addrs[NDIRECT+<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><p>xv6中有inode的缓冲区，作用与块缓冲区相似。以下函数分析仅包含进行特殊操作或较为复杂的函数，其余函数仅写出作用和使用条件（如<code>iunlock</code>）。其中函数位于<code>fs.c</code>。</p><h4 id="获取inode-iget"><a href="#获取inode-iget" class="headerlink" title="获取inode iget"></a>获取inode iget</h4><p><code>iget</code>返回的inode的指针将保证这个inode会留在缓存中，不会被删掉且不会被用于缓存另一个文件（即使未读入磁盘dinode内容）。若磁盘内容未读入，则以后在调用<code>ilock</code>时读入。</p><p>其中<code>iget</code>返回的inode的是未被锁的。在目录层的目录查找中，调用者已经对dp上锁，如果在调用<code>iget</code>返回之前尝试去锁上该i节点会有二次锁上dp的可能从而造成死锁。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">inode</span>*</span></span><br><span class="line"><span class="class"><span class="title">iget</span>(<span class="title">uint</span> <span class="title">dev</span>, <span class="title">uint</span> <span class="title">inum</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">ip</span>, *<span class="title">empty</span>;</span></span><br><span class="line"></span><br><span class="line">  acquire(&amp;icache.lock);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在inode的cache中寻找目标inode</span></span><br><span class="line">  empty = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(ip = &amp;icache.inode[<span class="number">0</span>]; ip &lt; &amp;icache.inode[NINODE]; ip++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(ip-&gt;ref &gt; <span class="number">0</span> &amp;&amp; ip-&gt;dev == dev &amp;&amp; ip-&gt;inum == inum)&#123;</span><br><span class="line">      ip-&gt;ref++;</span><br><span class="line">      release(&amp;icache.lock);</span><br><span class="line">      <span class="keyword">return</span> ip; <span class="comment">// 此时返回的i节点内容不一定已从磁盘读入cache</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(empty == <span class="number">0</span> &amp;&amp; ip-&gt;ref == <span class="number">0</span>)    <span class="comment">// 记录扫描到的第一个空槽</span></span><br><span class="line">      empty = ip;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 保持inode入口，以下未从磁盘读入内容</span></span><br><span class="line">  <span class="keyword">if</span>(empty == <span class="number">0</span>) <span class="comment">// cache中无i节点空闲，出错</span></span><br><span class="line">    panic(<span class="string">"iget: no inodes"</span>);</span><br><span class="line"></span><br><span class="line">  ip = empty;</span><br><span class="line">  ip-&gt;dev = dev;</span><br><span class="line">  ip-&gt;inum = inum;</span><br><span class="line">  ip-&gt;ref = <span class="number">1</span>;</span><br><span class="line">  ip-&gt;valid = <span class="number">0</span>;</span><br><span class="line">  release(&amp;icache.lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ip;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="分配inode-ialloc"><a href="#分配inode-ialloc" class="headerlink" title="分配inode ialloc"></a>分配inode ialloc</h4><p>在设备dev上分配inode：通过给它类型类型将其标记为已分配，返回未锁定但已分配和引用的inode。这里与<code>balloc</code>相似，可参照前文。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span>*</span></span><br><span class="line"><span class="class"><span class="title">ialloc</span>(<span class="title">uint</span> <span class="title">dev</span>, <span class="title">short</span> <span class="title">type</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">int</span> inum;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dinode</span> *<span class="title">dip</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(inum = <span class="number">1</span>; inum &lt; sb.ninodes; inum++)&#123;</span><br><span class="line">    bp = bread(dev, IBLOCK(inum, sb));</span><br><span class="line">    dip = (struct dinode*)bp-&gt;data + inum%IPB;</span><br><span class="line">    <span class="keyword">if</span>(dip-&gt;type == <span class="number">0</span>)&#123;  <span class="comment">// inode未分配</span></span><br><span class="line">      <span class="built_in">memset</span>(dip, <span class="number">0</span>, <span class="keyword">sizeof</span>(*dip)); <span class="comment">// 分配空间</span></span><br><span class="line">      dip-&gt;type = type;</span><br><span class="line">      log_write(bp);</span><br><span class="line">      brelse(bp);</span><br><span class="line">      <span class="keyword">return</span> iget(dev, inum);</span><br><span class="line">    &#125;</span><br><span class="line">    brelse(bp);</span><br><span class="line">  &#125;</span><br><span class="line">  panic(<span class="string">"ialloc: no inodes"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="锁inode-ilock"><a href="#锁inode-ilock" class="headerlink" title="锁inode ilock"></a>锁inode ilock</h4><p>锁定给定的inode。如有必要，从磁盘读取inode。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">ilock(struct inode *ip)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">bp</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dinode</span> *<span class="title">dip</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(ip == <span class="number">0</span> || ip-&gt;ref &lt; <span class="number">1</span>)</span><br><span class="line">    panic(<span class="string">"ilock"</span>);</span><br><span class="line"></span><br><span class="line">  acquiresleep(&amp;ip-&gt;lock); <span class="comment">// 请求inode锁</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(ip-&gt;valid == <span class="number">0</span>)&#123; <span class="comment">// inode内容未从磁盘读取</span></span><br><span class="line">    bp = bread(ip-&gt;dev, IBLOCK(ip-&gt;inum, sb));</span><br><span class="line">    dip = (struct dinode*)bp-&gt;data + ip-&gt;inum%IPB;</span><br><span class="line">    ip-&gt;type = dip-&gt;type;</span><br><span class="line">    ip-&gt;major = dip-&gt;major;</span><br><span class="line">    ip-&gt;minor = dip-&gt;minor;</span><br><span class="line">    ip-&gt;nlink = dip-&gt;nlink;</span><br><span class="line">    ip-&gt;size = dip-&gt;size;</span><br><span class="line">    memmove(ip-&gt;addrs, dip-&gt;addrs, <span class="keyword">sizeof</span>(ip-&gt;addrs));</span><br><span class="line">    brelse(bp);</span><br><span class="line">    ip-&gt;valid = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(ip-&gt;type == <span class="number">0</span>) <span class="comment">// inode未被分配，出错，引发恐慌</span></span><br><span class="line">      panic(<span class="string">"ilock: no type"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="释放引用-iput"><a href="#释放引用-iput" class="headerlink" title="释放引用 iput"></a>释放引用 iput</h4><p>释放对内存中的某一inode的引用，即引用数减一。对iput（）的所有调用必须在会话内，因为它可能释放inode。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">iput(struct inode *ip)</span><br><span class="line">&#123;</span><br><span class="line">  acquiresleep(&amp;ip-&gt;lock); <span class="comment">// 请求inode锁</span></span><br><span class="line">  <span class="comment">// 如果这是最后一个引用，则可以回收inode缓存条目。</span></span><br><span class="line">  <span class="keyword">if</span>(ip-&gt;valid &amp;&amp; ip-&gt;nlink == <span class="number">0</span>)&#123;</span><br><span class="line">    acquire(&amp;icache.lock);</span><br><span class="line">    <span class="keyword">int</span> r = ip-&gt;ref;</span><br><span class="line">    release(&amp;icache.lock);</span><br><span class="line">    <span class="keyword">if</span>(r == <span class="number">1</span>)&#123;</span><br><span class="line">      <span class="comment">// inode has no links and no other references: truncate and free.</span></span><br><span class="line">      <span class="comment">// 如果那是最后一个引用并且inode没有连接，释放磁盘上的inode（及其内容）。</span></span><br><span class="line">      itrunc(ip);</span><br><span class="line">      ip-&gt;type = <span class="number">0</span>;</span><br><span class="line">      iupdate(ip);</span><br><span class="line">      ip-&gt;valid = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  releasesleep(&amp;ip-&gt;lock); <span class="comment">// 释放 inode 锁</span></span><br><span class="line"></span><br><span class="line">  acquire(&amp;icache.lock);</span><br><span class="line">  ip-&gt;ref--; <span class="comment">// 引用计数减一</span></span><br><span class="line">  release(&amp;icache.lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="其他函数"><a href="#其他函数" class="headerlink" title="其他函数"></a>其他函数</h4><ul><li>readsb 读超级块</li><li>bzero 将块内容清零</li><li>iupdate 将修改后的内存中inode复制到磁盘；必须在每次更改ip-&gt; xxx字段后调用；它存在于磁盘上，因为i-node缓存是直写式的；调用者必须持有i节点锁。</li><li>iunlock 对指定inode解锁</li><li>iunlockput iunlock和iput的结合。由于两种常常一起使用，故整合。</li><li>bmap 返回inode中第n个块的磁盘块地址，如果没有这样的块，bmap会分配一个。</li><li>stati 从inode复制属性信息。</li><li>readi 从inode读数据，调用者必须持有ip-&gt; lock。</li><li>writei 给inode写入数据，调用者必须持有ip-&gt; lock。</li></ul><p><em>其中readi和writei均要求给定的偏移和读出的量不超出文件大小。</em></p><h3 id="目录层"><a href="#目录层" class="headerlink" title="目录层"></a>目录层</h3><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><p>目录的i节点的类型是T_DIR,.目录本身是以文件的方式存储到磁盘上的，它的数据是一系列的目录条目。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> &#123;</span></span><br><span class="line">  ushort inum; <span class="comment">// i节点号</span></span><br><span class="line">  <span class="keyword">char</span> name[DIRSIZ]; <span class="comment">// 目录名</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p>详细注释位于<code>fs.c</code>。</p><ul><li>dirlookup 查找目录中指定名字的条目</li><li>dirlink 会写入一个新的目录条目到某一目录下</li></ul><h3 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h3><h4 id="函数-1"><a href="#函数-1" class="headerlink" title="函数"></a>函数</h4><ul><li>namex </li></ul><p>查找并返回inode以获取路径名。如果parent！= 0，则返回父项的inode并复制最终项。路径元素到名称，必须有DIRSIZ字节的空间。该函数必须在会话内部调用，因为它调用iput（）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">inode</span>*</span></span><br><span class="line"><span class="class"><span class="title">namex</span>(<span class="title">char</span> *<span class="title">path</span>, <span class="title">int</span> <span class="title">nameiparent</span>, <span class="title">char</span> *<span class="title">name</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">ip</span>, *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(*path == <span class="string">'/'</span>) <span class="comment">// 路径以反斜杠开始，则解析从根目录开始</span></span><br><span class="line">    ip = iget(ROOTDEV, ROOTINO);</span><br><span class="line">  <span class="keyword">else</span> <span class="comment">// 其他情况下则从当前目录开始</span></span><br><span class="line">    ip = idup(myproc()-&gt;cwd);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>((path = skipelem(path, name)) != <span class="number">0</span>)&#123; <span class="comment">// 考虑路径中的每一个部分</span></span><br><span class="line">    ilock(ip); <span class="comment">// 确保ip-&gt;type从磁盘中加载出来</span></span><br><span class="line">    <span class="keyword">if</span>(ip-&gt;type != T_DIR)&#123; <span class="comment">// 不是目录，查找失败</span></span><br><span class="line">      iunlockput(ip);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后一个路径元素，循环提前结束</span></span><br><span class="line">    <span class="keyword">if</span>(nameiparent &amp;&amp; *path == <span class="string">'\0'</span>)&#123;</span><br><span class="line">      <span class="comment">// Stop one level early. </span></span><br><span class="line">      iunlock(ip);</span><br><span class="line">      <span class="keyword">return</span> ip;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>((next = dirlookup(ip, name, <span class="number">0</span>)) == <span class="number">0</span>)&#123; <span class="comment">// 寻找路径元素失败，查找失败</span></span><br><span class="line">      iunlockput(ip);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    iunlockput(ip);</span><br><span class="line">    ip = next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(nameiparent)&#123;</span><br><span class="line">    iput(ip);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ip;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>skipelem 将路径中的下一个路径元素复制到名称中，返回指向复制后的元素的指针。</li><li>namei 解析path并返回对应的inode。</li><li>nameiparent 返回上级目录的i节点并且把最后一个元素拷贝到name中。</li></ul><p><em>函数的详细内容位于<code>fs.c</code></em></p><h3 id="文件描述符层"><a href="#文件描述符层" class="headerlink" title="文件描述符层"></a>文件描述符层</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> &#123;</span></span><br><span class="line">  <span class="keyword">enum</span> &#123; FD_NONE, FD_PIPE, FD_INODE &#125; type; <span class="comment">// 文件分为管道文件和普通文件等，FD_NONE表示文件未使用</span></span><br><span class="line">  <span class="keyword">int</span> ref; <span class="comment">// reference count 引用计数</span></span><br><span class="line">  <span class="keyword">char</span> readable; <span class="comment">// 可读</span></span><br><span class="line">  <span class="keyword">char</span> writable; <span class="comment">// 可写</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">pipe</span> *<span class="title">pipe</span>;</span> <span class="comment">// 管道</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">ip</span>;</span> <span class="comment">// 指向i节点</span></span><br><span class="line">  uint off;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>xv6中每个进程都有自己的打开文件表。每个打开文件均由上面的结构体表示，它是一个对i节点或者管道和文件偏移的封装。每次调用<code>open</code>都会创建一个新的file结构体。</p><p>如果多个进程相互独立地打开了同一个文件，不同的实例将拥有不同的I/O偏移。而且同一个file结构体可以在一个进程的文件表中多次出现，同时也可以在多个进程的文件表中出现。对每一个打开的文件都有一个引用计数，一个文件可以被打开用于读、写或者二者。</p><p>系统中所有的打开文件都存在于一个全局的文件表<code>ftable</code>中。</p><h4 id="函数-2"><a href="#函数-2" class="headerlink" title="函数"></a>函数</h4><p>该层的函数位于<code>file.c</code>，详细注释见代码文件。</p><ul><li>filealloc 分配文件，扫描整个文件表寻找没有被引用的文件并返回一个新的引用。</li><li>filedup 重复引用文件，增加引用计数。</li><li>fileclose 释放对文件引用的函数，减少引用计数，当一个文件的引用计数变为0的时候，根据文件类型的不同,释放掉当前的管道或者i节点。</li><li>fileread 读文件，实现对文件的<code>read</code>操作</li><li>filewrite 写文件，实现对文件的<code>write</code>操作。</li><li>filestat 获取文件的元信息，实现对文件的<code>stat</code>操作（只允许作用在inode）。</li></ul><h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p>暂无内容。</p><h2 id="文件系统中xv6可改进之处"><a href="#文件系统中xv6可改进之处" class="headerlink" title="文件系统中xv6可改进之处"></a>文件系统中xv6可改进之处</h2><h3 id="cache"><a href="#cache" class="headerlink" title="cache"></a>cache</h3><ol><li>使用的替换策略为LRU，算法较为简单。</li><li>链表的使用虽然实现简单，但查找效率低，时间复杂度高。若能使用哈希表等实现查找可提高效率。</li></ol><h3 id="目录查找"><a href="#目录查找" class="headerlink" title="目录查找"></a>目录查找</h3><p>目录查找为线性查找，在目录数量较多的情况下耗时巨大。若能使用树等结构，便能大大减小时间复杂度。</p><h3 id="大小固定"><a href="#大小固定" class="headerlink" title="大小固定"></a>大小固定</h3><p>文件系统的大小在xv6中是不改变的，固定在一个磁盘设备上。这一点对于个人PC影响不大，但在需要存储大量文件或超大文件的情况下，便有些捉襟见肘。</p>]]></content>
    
    <summary type="html">
    
      xv6操作系统之文件系统源码阅读与分析
    
    </summary>
    
      <category term="操作系统" scheme="http://rootreturn0.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="学习" scheme="http://rootreturn0.github.io/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
</feed>
