{"meta":{"title":"〇","subtitle":"世界的本质即是无限的循环","description":null,"author":"rootReturn0","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"Android学习笔记_Activity","slug":"Android学习笔记-Activity","date":"2019-10-18T14:07:48.000Z","updated":"2019-10-18T15:06:50.334Z","comments":true,"path":"2019/10/18/Android学习笔记-Activity/","link":"","permalink":"http://yoursite.com/2019/10/18/Android学习笔记-Activity/","excerpt":"笔记基于郭震大神所著的《第一行代码》第二版之第2章。 其中： 使用的IDE：Android Studio 示例项目名：ActivityTest 包名：“com.example.avtivity.test”","text":"笔记基于郭震大神所著的《第一行代码》第二版之第2章。 其中： 使用的IDE：Android Studio 示例项目名：ActivityTest 包名：“com.example.avtivity.test” 活动的基本用法手动创建活动新建项目时选择Add No Activity 初始文件结构 右击com.example.activitytest包-&gt;New-&gt;Activity-&gt;Empty Activity，会弹出对话框，其中 Generate LayoutFile 会在app/src/main/res目录中为该活动自动生成对应的 layout 的 xml 文件；Launcher Activity 会将该活动设置为程序运行时首先加载的活动，即当前项目的主活动。 创建和加载布局右击app/src/main/res目录-&gt;New-&gt;Directory，可创建一个名为 layout 的目录，而后右击该目录，即可新建布局文件。 添加按钮12345678910111213&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:orientation=\"vertical\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;Button android:id=\"@+id/button_1\" // 定义id android:layout_width=\"match_parent\" // 表示和父元素一样宽 android:layout_height=\"wrap_content\" // 表示当前元素的高度恰好包含里面内容 android:text=\"Button_1\" /&gt;&lt;/LinearLayout&gt; 加载123456789101112131415package com.example.activitytest;import androidx.appcompat.app.AppCompatActivity;import android.os.Bundle;public class FirstActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); // 本行将layout的id传入，为当前活动加载布局 setContentView(R.layout.thirt_layout); &#125;&#125; 在AndroidManifest文件注册1234567891011121314151617181920212223&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" package=\"com.example.activitytest\"&gt; &lt;application android:allowBackup=\"true\" android:icon=\"@mipmap/ic_launcher\" android:label=\"@string/app_name\" android:roundIcon=\"@mipmap/ic_launcher_round\" android:supportsRtl=\"true\" android:theme=\"@style/AppTheme\"&gt; &lt;activity android:name=\".FirstActivity\" // 指定注册活动 android:label=\"This is FirstActivity\" &gt; // 指定活动标题栏内容 &lt;intent-filter&gt; // 以下两行将活动配置为主活动 &lt;action android:name=\"android.intent.action.MAIN\" /&gt; &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;/application&gt;&lt;/manifest&gt; Toast及按钮响应123456789101112protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.first_layout); Button button1 = (Button) findViewById(R.id.button_1); button1.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; Toast.makeText(FirstActivity.this, \"You clicked Button_1!\", Toast.LENGTH_SHORT).show(); &#125; &#125;); &#125; 通过 findViewById() 方法获取到布局文件中定义的元素，这里传入 R.id.button_1 来得到按钮的实例，而后注册监听器。 Toast 中 makeText 有三个参数，第一个是 Context（活动是一种上下文），第二个参数是 Toast 显示的文本内容，第三个是持续时长。注意，只有加上后面的 .show() ，Toast 才会显示。 Menu使用 Android 提供的方式创建菜单。菜单通过应用右上角的三个点的小按钮，以列表形式显示。 创建菜单右击app/src/main/res目录-&gt;New-&gt;Directory，创建名为 menu 的文件夹，并在文件夹下创建一个名为 main 的菜单文件（右击menu-&gt;New-&gt;Menu resource file）。 在main.xml添加如下代码： 123456789&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;menu xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;item android:id=\"@+id/add_item\"// 标识符 android:title=\"Add\" // 名称 /&gt; &lt;item android:id=\"@+id/remove_item\" android:title=\"Remove\" /&gt;&lt;/menu&gt; 其中item标签用来创建具体的菜单项。 而后在FirstActivity中重写函数： 123456public boolean onCreateOptionsMenu(Menu menu)&#123; // 第一个参数为资源文件，第二个指定添加到的Menu对象 getMenuInflater().inflate(R.menu.main, menu); // 表示是否允许显示菜单 return true; &#125; 菜单响应在FirstActivity中重写函数： 1234567891011121314public boolean onOptionsItemSelected(@NonNull MenuItem item) &#123; // 判断点击的菜单项 switch (item.getItemId())&#123; case R.id.add_item: Toast.makeText(this,\"You clicked Add\",Toast.LENGTH_SHORT).show(); break; case R.id.remove_item: Toast.makeText(this,\"You clicked Remove\",Toast.LENGTH_LONG).show(); break; default: &#125; return super.onOptionsItemSelected(item); &#125; 销毁活动在模拟器中按下 Back 键，或调用finish()方法。 1234567891011protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.first_layout); Button button1 = (Button) findViewById(R.id.button_1); button1.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; finish() &#125; &#125;); &#125;","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[{"name":"学习","slug":"学习","permalink":"http://yoursite.com/tags/学习/"}]},{"title":"Haydn","slug":"Haydn","date":"2019-10-07T18:12:49.000Z","updated":"2019-10-07T18:20:37.943Z","comments":true,"path":"2019/10/08/Haydn/","link":"","permalink":"http://yoursite.com/2019/10/08/Haydn/","excerpt":"","text":"有时并非欢快地跳跃着的。 但却依旧舒缓人疲惫的心灵。 非山河壮阔， 非人间星火， 非天外飞仙。 而是流淌在春天的生死明灭。","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"H","slug":"H","date":"2019-10-07T09:33:27.000Z","updated":"2019-10-07T10:00:43.325Z","comments":true,"path":"2019/10/07/H/","link":"","permalink":"http://yoursite.com/2019/10/07/H/","excerpt":"我又梦到她了。 翩翩君子，温润如玉。","text":"我又梦到她了。 翩翩君子，温润如玉。 Memory不记得是哪个yu了。 过去的事情在一点一点地被遗忘，现在的事情也正在一点一点地被遗忘。 那感受确切地存在于过去，如今回想起来仍然强烈。却不知是否现在为真，还是过去为真。 但遗忘是真的。 Moment某些因她而触发的机能正在消逝，甚至比未曾到来时更加彻底。我在退化，我无法思考，我无法记忆。 无法阻止。 我似乎知道为何，但不知流星为什么要划过夜空。 MonumentTo be or not to be? It’s not a question.","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"R","slug":"C","date":"2019-10-07T09:28:19.000Z","updated":"2019-10-07T10:09:26.229Z","comments":true,"path":"2019/10/07/C/","link":"","permalink":"http://yoursite.com/2019/10/07/C/","excerpt":"","text":"在曾经最低谷的时候（极小值）， 她激励了我； 在现在最底谷的时候（极小值）， 她安慰了我。 果然是我生命中重要的一个人（笑 CAUSE AND CONSEQUENCE","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]},{"title":"xv6-调度","slug":"xv6-调度","date":"2019-08-31T10:50:22.000Z","updated":"2019-08-31T13:32:59.676Z","comments":true,"path":"2019/08/31/xv6-调度/","link":"","permalink":"http://yoursite.com/2019/08/31/xv6-调度/","excerpt":"","text":"调度由于可能同时有多个CPU请求进行调度，故需要进程表锁ptable.lock来避免竞争。 因此，进程在让出CPU前，必须要获得进程表锁，并释放其拥有的其他锁（避免同时持有多个锁导致死锁），修改自己的状态proc-&gt;state，然后进行调度。 函数以下函数位于代码文件proc.c中。 sched进程进入调度器，且必须持有进程表锁并改变进程状态。由于进程此时持有进程表锁，所以CPU应该是在关中断的情况下运行。 12345678910111213141516171819202122voidsched(void)&#123; int intena; struct proc *p = myproc(); // 未持有进程表锁，不应进入调度，引发内核错误 if(!holding(&amp;ptable.lock)) panic(\"sched ptable.lock\"); // 处于锁状态，不应进入调度，引发内核错误 if(mycpu()-&gt;ncli != 1) panic(\"sched locks\"); // 进程处于运行态，不应进入调度，引发内核错误 if(p-&gt;state == RUNNING) panic(\"sched running\"); // 开中断，不可执行mycpu()函数，不应进入调度，引发内核错误 if(readeflags()&amp;FL_IF) panic(\"sched interruptible\"); intena = mycpu()-&gt;intena; // 暂存状态 swtch(&amp;p-&gt;context, mycpu()-&gt;scheduler); // 保存当前上下文，并切换到之前保存的调度器的上下文，进入调度器 mycpu()-&gt;intena = intena; // 恢复状态&#125; yield在xv6中，使用时间片轮转法进行调度。当进程用完它的CPU时间片时，时钟中断会调用yield函数来让出CPU给新的进程，yield调用sched函数，sched调用swtch来切换都调度器线程： 12345678voidyield(void)&#123; acquire(&amp;ptable.lock); //DOC: yieldlock 请求进程表锁 myproc()-&gt;state = RUNNABLE; // 切换进程状态 sched(); release(&amp;ptable.lock); // 释放进程表锁&#125; scheduler每个CPU在设置完成自己之后调用scheduler。 调度器scheduler永远不会返回，而是不断循环。循环步骤为： 选择要运行的流程 swtch开始运行该过程 最终该过程通过swtch将控制转移回调度程序。 1234567891011121314151617181920212223242526272829303132333435363738voidscheduler(void)&#123; struct proc *p; struct cpu *c = mycpu(); c-&gt;proc = 0; // 不断循环，永不停止 for(;;)&#123; // 开中断，以允许I/O到达 sti(); // 在进程表上不断循环，寻找进程并运行 acquire(&amp;ptable.lock); // 请求进程表锁 for(p = ptable.proc; p &lt; &amp;ptable.proc[NPROC]; p++)&#123; if(p-&gt;state != RUNNABLE) // 进程不可运行，转到下一个进程 continue; // Switch to chosen process. It is the process's job // to release ptable.lock and then reacquire it // before jumping back to us. // 切换到选定的进程 c-&gt;proc = p; switchuvm(p); // 切换到该进程的页表 p-&gt;state = RUNNING; swtch(&amp;(c-&gt;scheduler), p-&gt;context); // 切换到该进程运行 switchkvm(); // 当没有进程正在运行时，将页表寄存器切换到仅内核页表。 // Process is done running for now. // It should have changed its p-&gt;state before coming back. // 进程已结束运行，改变自身状态 c-&gt;proc = 0; &#125; release(&amp;ptable.lock); // 释放进程表锁，防止其他CPU无法进行调度 &#125;&#125; 锁与中断锁 为保证进程状态的上下文在运行swtch时保持不变：进程表锁由旧进程获得，新进程释放。 为防止其他CPU闲置时锁被当前CPU占有而无法调度，其他CPU上运行进程无法让出CPU，导致死锁的情况：在遍历一次进程表后总要释放锁。 中断 为防止所有进程都在等待I/O时关中断导致的I/O无法到达引发的死锁，调度器在每次循坏开始前进行开中断。 睡眠与唤醒函数sleep和wakeup位于代码文件proc.c中。 使进程进入睡眠或进行唤醒均需要改变进程状态，故需要进程表锁以保证状态修改的原子性。其中函数sleep要在使进程进入睡眠前获取进程表锁，以保证在使函数进入睡眠时至少持有一个锁，防止wakeup在进程进入睡眠前被调用导致的死锁。当sleep本身持有的锁为进程表锁时，则略过请求这一步，防止死锁。 可改进之处调度 轮转法无优先级的区分 会导致高优先级的进程无法优先运行，可能导致系统运行时间的增加，影响使用者在实际使用时的体验。可使用其他较为复杂的算法，如高响应比优先算法等以改进体验。 睡眠与唤醒 唤醒需要遍历进程表 在进程数量大的时候这种做法效率极低。使用另一个结构体来维护链表可大大提高效率。 唤醒时会唤醒队列中全部进程 大多数情况下，同一时间需要唤醒的进程在队列中是少数部分，许多仍需等待的进程将会被“莫名其妙”地唤醒并再度检查状态重新进入睡眠，导致操作系统需要处理许多新的不必要的任务。 唤醒时应分为个体唤醒（唤醒单个进程）和群体唤醒（唤醒所有进程），减少系统负担。","categories":[],"tags":[{"name":"学习","slug":"学习","permalink":"http://yoursite.com/tags/学习/"}]},{"title":"xv6-管道","slug":"xv6-管道","date":"2019-08-31T00:29:38.000Z","updated":"2019-08-31T16:07:10.652Z","comments":true,"path":"2019/08/31/xv6-管道/","link":"","permalink":"http://yoursite.com/2019/08/31/xv6-管道/","excerpt":"","text":"管道从管道的一端写入数据字节，然后数据被拷贝到内核缓冲区中，接着进程就能从管道的另一端读取数据了。 在xv6中，管道使用被读取字节数nread和被写入字节数nwrite的差值判断管道状态： nwrite == nread 则数据未写入或被读取完毕，管道空 nwrite == nread + PIPESIZE 则管道满 由于管道的读取与写入均需要使用nread和nwrite以获悉管道状态，故这两个计数参数不能在某一函数（写入/读取）清零，否则将影响另一函数（读取/写入）的执行。因此，xv6中使用data[nread % PIPESIZE]和data[nwrite % PIPESIZE]来控制读写时的管道数据偏移，即循环写/读，在data[PIPESIZE-1]后写入的数据存放在data[0]中。 数据结构12345678struct pipe &#123; struct spinlock lock; // 锁 char data[PIPESIZE]; // 管道数据 uint nread; // 被读取字节数，从缓冲区中读取 uint nwrite; // 被写入字节数，写入缓冲区 int readopen; // 读文件描述符是否依旧处于open状态 int writeopen; // 写文件描述符是否依旧处于open状态&#125;; 管道函数以下分析管道读写函数，其他函数仅列出函数作用，详细注释见代码文件pipe.c。 读写管道读写操作通过管道锁实现互斥，操作运行时必须持有管道锁。 管道数据写入时首先获取管道锁而后写入数据，若达到管道容量上限，则写操作唤醒读操作后进入睡眠等待并释放管道锁。此时读操作可获得请求的管道锁，在读取完数据后管道变空，则读操作唤醒写操作后进入睡眠等待并释放管道锁。而后管道写操作再次获得管道锁，循环往复直至数据传输完毕，其中最后一次传输可能未写满管道。 当使用管道的操作被杀后，管道读写操作都将终止；当管道不可读时，管道写操作将被终止。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// 管道写intpipewrite(struct pipe *p, char *addr, int n)&#123; int i; acquire(&amp;p-&gt;lock); // 请求获得管道锁，以保护计数器、数据以及相关不变量 for(i = 0; i &lt; n; i++)&#123; while(p-&gt;nwrite == p-&gt;nread + PIPESIZE)&#123; // 管道满 // 如果管道文件不可读或进程被杀，释放管道锁并终止管道写操作 if(p-&gt;readopen == 0 || myproc()-&gt;killed)&#123; release(&amp;p-&gt;lock); return -1; &#125; wakeup(&amp;p-&gt;nread); // 通知睡眠中的读者缓冲区中有数据可读 sleep(&amp;p-&gt;nwrite, &amp;p-&gt;lock); // 管道写操作进入睡眠等待（睡眠时将释放管道锁） &#125; p-&gt;data[p-&gt;nwrite++ % PIPESIZE] = addr[i]; // 将所需读取的块内数据赋值给管道数据 &#125; wakeup(&amp;p-&gt;nread); // 通知睡眠中的读者缓冲区中有数据可读 release(&amp;p-&gt;lock); // 释放管道锁 return n;&#125;//管道读intpiperead(struct pipe *p, char *addr, int n)&#123; int i; acquire(&amp;p-&gt;lock); // 请求获得管道锁，以保护计数器、数据以及相关不变量 while(p-&gt;nread == p-&gt;nwrite &amp;&amp; p-&gt;writeopen)&#123; //DOC: 管道为空且管道可写，则管道读操作可进入睡眠 // 进程被杀，释放管道锁，终止管道读操作 if(myproc()-&gt;killed)&#123; release(&amp;p-&gt;lock); return -1; &#125; sleep(&amp;p-&gt;nread, &amp;p-&gt;lock); //DOC: piperead-sleep 管道读操作进入睡眠等待（睡眠时将释放管道锁） &#125; for(i = 0; i &lt; n; i++)&#123; // 拷贝数据 if(p-&gt;nread == p-&gt;nwrite) // 读取字节数等于写入字节数，表示读取完成 break; addr[i] = p-&gt;data[p-&gt;nread++ % PIPESIZE]; // 将所需读取的管道数据赋值给块内数据 &#125; wakeup(&amp;p-&gt;nwrite); // 通知睡眠中的写者缓冲区中可写 release(&amp;p-&gt;lock); return i;&#125; 其他 pipealloc 管道分配，并初始化管道。 pipeclose 管道关闭。若读写两方均关闭，则释放内存；否则关闭管道一端并唤醒另一方。当关闭写端时，仍可进行读操作，但将管道内剩余数据读完后，再次进行读操作便返回0，相当于读到文件末尾；当关闭读段时，写操作会在进行过程中中断。","categories":[],"tags":[{"name":"学习","slug":"学习","permalink":"http://yoursite.com/tags/学习/"}]},{"title":"xv6-文件系统","slug":"xv6-文件系统","date":"2019-08-30T17:47:50.000Z","updated":"2019-08-31T00:26:38.022Z","comments":true,"path":"2019/08/31/xv6-文件系统/","link":"","permalink":"http://yoursite.com/2019/08/31/xv6-文件系统/","excerpt":"","text":"文件系统总体设计文件系统分层 如图所示xv6的文件系统分6层实现： 第一层（自下而上）通过块缓冲读写 IDE 硬盘，同步对磁盘的访问，且通过块的锁保证同一时间只有一个内核进程可以修改磁盘块； 第二层使得更高层的接口可以将对磁盘的更新按会话打包，通过会话的方式来保证这些操作是原子操作。 第三层提供无名文件，每一个文件由一个inode和一连串的数据块组成。 第四层将目录实现为一种特殊的inode，内容是一连串的目录项，每一个目录项包含一个文件名和对应的inode。 第五层提供了层次路经名（如/xx/xxx），这一层通过递归的方式来查询路径对应的文件。 第六层将许多资源（如管道，设备，文件等）抽象为文件系统的接口，极大地简化了程序员的工作。 磁盘分层磁盘分层为引导块、超级块、日志块、inode块、空闲块位图和数据块等。 文件系统不使用引导块；超级块包含了文件系统的元信息；日志块中的日志维护了文件系统操作的原子性，防止操作过程中引发的系统崩溃而导致的数据不同步；inode块用于存放inode（一个块可存放多个inode）；空闲块位图便于查找空闲的块；数据块中保存了文件和目录等内容。 块缓冲层需要实现的目标 同步对磁盘的访问。对于任意一个块，同一时间仅有一份拷贝放在内存中且只允许一个内核线程对该拷贝进行修改。 缓存常用的块以减少磁盘读取次数，提高系统效率。 实现方案代码参见bio.c。 根据时间与空间局部性原理，将最近经常访问的磁盘块缓存在内存中，并使用LRU替换策略。 结构定义xv6将缓冲区分为两种状态： B_VALID 意味着这个缓冲区拥有磁盘块的有效内容； B_DIRTY 意味着缓冲区的内容已经被改变并且需要写回磁盘； 与旧版相比，B_BUSY 状态在最新版代码中被删去。但由于缓存区中的块的锁的存在，只有持有锁才能访问该块，而在另一线程未使用完成前，该锁不会被释放，此时只能循环等待锁的释放，获得锁后方可获得块。故依旧可保持块内容的原子性。 12345678910111213141516171819202122// 内存中的磁盘块结构struct buf &#123; int flags; // 标记磁盘状态，valid/dirty uint dev; // 磁盘设备号 uint blockno; // 块编号 struct sleeplock lock; uint refcnt; // 引用计数 struct buf *prev; // LRU cache list 使用LRU替换 struct buf *next; // 链式结构连接磁盘块 struct buf *qnext; // 磁盘队列 uchar data[BSIZE]; // 块大小为512字节&#125;;// 块缓冲区结构struct &#123; struct spinlock lock; struct buf buf[NBUF]; // 通过 prev/next 连接所有缓冲块 // 其中 head.next 是最近最常使用的块. struct buf head;&#125; bcache; 初始化 binit从一个静态数组buf中构建出一个有NBUF个元素的双向链表。所有对块缓冲的访问都通过链表而非静态数组。 123456789101112131415161718192021voidbinit(void)&#123; struct buf *b; // 初始化块缓冲锁 initlock(&amp;bcache.lock, \"bcache\");//PAGEBREAK! // 构建缓冲双向链表 bcache.head.prev = &amp;bcache.head; bcache.head.next = &amp;bcache.head; for(b = bcache.buf; b &lt; bcache.buf+NBUF; b++)&#123; b-&gt;next = bcache.head.next; b-&gt;prev = &amp;bcache.head; // 初始化缓冲区中的块的锁 initsleeplock(&amp;b-&gt;lock, \"buffer\"); bcache.head.next-&gt;prev = b; bcache.head.next = b; &#125;&#125; 查找 bget扫描缓冲区链表，通过给定的设备号和扇区号找到对应的缓冲区。如果未找到，则分配一个缓冲区，否则返回一个持有锁的缓冲区。代码中在双向链表的搜索中向最近最常使用方向查找，若未找到则向另一方向查找空闲缓冲区以分配。 其中若找到缓冲区中指定的块，返回的结果也不一定是指定的块。因为在请求该块的锁前已释放缓冲区锁，若该块未持有锁且正在被用来缓冲另外一个块，则重新获得锁时已是另一个块。 123456789101112131415161718192021222324252627282930313233343536static struct buf*bget(uint dev, uint blockno)&#123; struct buf *b; acquire(&amp;bcache.lock); // 请求块缓冲区锁 // 不能保证 b 仍然是可用的缓冲区：它有可能被用来缓冲另外一个块。 for(b = bcache.head.next; b != &amp;bcache.head; b = b-&gt;next)&#123; if(b-&gt;dev == dev &amp;&amp; b-&gt;blockno == blockno)&#123; b-&gt;refcnt++; // 引用计数加一 release(&amp;bcache.lock); // 释放块缓冲区锁 acquiresleep(&amp;b-&gt;lock); // 请求该块的锁 return b; &#125; &#125; // Not cached; recycle an unused buffer. 未找到则重新查找 // Even if refcnt==0, B_DIRTY indicates a buffer is in use // because log.c has modified it but not yet committed it. // 即使refcnt等于0，也可通过B_DIRTY知道缓冲区被使用，此时日志已修改但未提交 for(b = bcache.head.prev; b != &amp;bcache.head; b = b-&gt;prev)&#123; if(b-&gt;refcnt == 0 &amp;&amp; (b-&gt;flags &amp; B_DIRTY) == 0) &#123; b-&gt;dev = dev; b-&gt;blockno = blockno; b-&gt;flags = 0; b-&gt;refcnt = 1; release(&amp;bcache.lock); acquiresleep(&amp;b-&gt;lock); return b; &#125; &#125; // 未找到块且未能分配块，引发内核错误 panic(\"bget: no buffers\");&#125; 读 breadbread会首先调用bget从缓存中去寻找块是否存在。如果存在直接返回；如果不存在则请求磁盘读操作，读到缓存中后再返回结果。 12345678910111213struct buf*bread(uint dev, uint blockno)&#123; struct buf *b; // 获取缓冲区 b = bget(dev, blockno); // 如果缓冲区中不存在指定的块，则从磁盘中读出 if((b-&gt;flags &amp; B_VALID) == 0) &#123; iderw(b); &#125; return b;&#125; 写 bwrite设置 B_DIRTY 位并且调用 iderw 将缓冲区的内容写到磁盘。 123456789voidbwrite(struct buf *b)&#123; // 该块未锁，可能已被释放，无法写入，引发内核错误 if(!holdingsleep(&amp;b-&gt;lock)) panic(\"bwrite\"); b-&gt;flags |= B_DIRTY; iderw(b);&#125; 释放 brelse将一块缓冲区移动到链表的头部，唤醒睡眠在这块缓冲区上的进程。 123456789101112131415161718192021222324// 唤醒睡眠在这块缓冲区上的进程；将一块缓冲区移动到链表的头部。voidbrelse(struct buf *b)&#123; // 缓冲区未持有块锁，引发内核错误 if(!holdingsleep(&amp;b-&gt;lock)) panic(\"brelse\"); releasesleep(&amp;b-&gt;lock); // 释放块锁 acquire(&amp;bcache.lock); // 请求 缓冲区锁 b-&gt;refcnt--; //引用计数减一 if (b-&gt;refcnt == 0) &#123; // 无进程等待使用，移动到链表头部 b-&gt;next-&gt;prev = b-&gt;prev; b-&gt;prev-&gt;next = b-&gt;next; b-&gt;next = bcache.head.next; b-&gt;prev = &amp;bcache.head; bcache.head.next-&gt;prev = b; bcache.head.next = b; &#125; release(&amp;bcache.lock); //释放缓冲区锁&#125; 日志层每一个系统调用都可能包含一个必须从头到尾原子完成的写操作序列，称这样的一个序列为一个会话。任何时候只能有一个进程在一个会话之中，其他进程必须等待当前会话中的进程结束。因此同一时刻日志最多只记录一次会话。 该层用于维护系统崩溃后到原子性，即会话要么完成，要么系统恢复至会话开始前的状态。 块分配器本部分涉及的函数位于fs.c。 由于bread与brelse已有锁进行互斥，块分配器无需再加锁。 分配新的磁盘块123456789101112131415161718192021222324static uintballoc(uint dev)&#123; int b, bi, m; struct buf *bp; bp = 0; for(b = 0; b &lt; sb.size; b += BPB)&#123; // 读位图每一块 bp = bread(dev, BBLOCK(b, sb)); for(bi = 0; bi &lt; BPB &amp;&amp; b + bi &lt; sb.size; bi++)&#123; // 读块内每一位 m = 1 &lt;&lt; (bi % 8); if((bp-&gt;data[bi/8] &amp; m) == 0)&#123; // 判断块是否空闲 bp-&gt;data[bi/8] |= m; // 将块标记为使用中 log_write(bp); brelse(bp); // 释放块 bzero(dev, b + bi); // 清零块 return b + bi; &#125; &#125; brelse(bp); &#125; // 超出块范围，引发错误 panic(\"balloc: out of blocks\");&#125; 释放磁盘块12345678910111213141516static voidbfree(int dev, uint b)&#123; struct buf *bp; int bi, m; readsb(dev, &amp;sb); bp = bread(dev, BBLOCK(b, sb)); bi = b % BPB; m = 1 &lt;&lt; (bi % 8); if((bp-&gt;data[bi/8] &amp; m) == 0) // 释放空闲块，错误 panic(\"freeing free block\"); bp-&gt;data[bi/8] &amp;= ~m; log_write(bp); brelse(bp); // 释放块&#125; inodeinode有两种类别： 磁盘上的记录文件大小、数据块扇区号的数据结构 12345678struct dinode &#123; short type; // 区分文件、目录和特殊文件的 i 节点，0表示为空闲节点 short major; // 主设备号（仅限T_DEV） short minor; // 辅设备号（仅限T_DEV） short nlink; // 文件系统中的i节点连接数 uint size; // 文件的字节数 uint addrs[NDIRECT+1]; // 用于这个文件的数据块的块号&#125;; 内存中的一个 i 节点，包含一个磁盘上 i 节点的拷贝，以及一些内核需要的附加信息 123456789101112131415struct inode &#123; uint dev; // Device number 设备号 uint inum; // Inode number inode号 int ref; // Reference count 引用数 struct sleeplock lock; // protects everything below here 保护以下所有数据 int valid; // inode has been read from disk? i节点是否已从磁盘中读取 // 以下均为磁盘上的i节点，即dinode，的拷贝 short type; // copy of disk inode short major; short minor; short nlink; uint size; uint addrs[NDIRECT+1];&#125;; xv6中有inode的缓冲区，作用与块缓冲区相似。以下函数分析仅包含进行特殊操作或较为复杂的函数，其余函数仅写出作用和使用条件（如iunlock）。其中函数位于fs.c。 获取inode igetiget返回的inode的指针将保证这个inode会留在缓存中，不会被删掉且不会被用于缓存另一个文件（即使未读入磁盘dinode内容）。若磁盘内容未读入，则以后在调用ilock时读入。 其中iget返回的inode的是未被锁的。在目录层的目录查找中，调用者已经对dp上锁，如果在调用iget返回之前尝试去锁上该i节点会有二次锁上dp的可能从而造成死锁。 1234567891011121314151617181920212223242526272829303132static struct inode*iget(uint dev, uint inum)&#123; struct inode *ip, *empty; acquire(&amp;icache.lock); // 在inode的cache中寻找目标inode empty = 0; for(ip = &amp;icache.inode[0]; ip &lt; &amp;icache.inode[NINODE]; ip++)&#123; if(ip-&gt;ref &gt; 0 &amp;&amp; ip-&gt;dev == dev &amp;&amp; ip-&gt;inum == inum)&#123; ip-&gt;ref++; release(&amp;icache.lock); return ip; // 此时返回的i节点内容不一定已从磁盘读入cache &#125; if(empty == 0 &amp;&amp; ip-&gt;ref == 0) // 记录扫描到的第一个空槽 empty = ip; &#125; // 保持inode入口，以下未从磁盘读入内容 if(empty == 0) // cache中无i节点空闲，出错 panic(\"iget: no inodes\"); ip = empty; ip-&gt;dev = dev; ip-&gt;inum = inum; ip-&gt;ref = 1; ip-&gt;valid = 0; release(&amp;icache.lock); return ip;&#125; 分配inode ialloc在设备dev上分配inode：通过给它类型类型将其标记为已分配，返回未锁定但已分配和引用的inode。这里与balloc相似，可参照前文。 123456789101112131415161718192021struct inode*ialloc(uint dev, short type)&#123; int inum; struct buf *bp; struct dinode *dip; for(inum = 1; inum &lt; sb.ninodes; inum++)&#123; bp = bread(dev, IBLOCK(inum, sb)); dip = (struct dinode*)bp-&gt;data + inum%IPB; if(dip-&gt;type == 0)&#123; // inode未分配 memset(dip, 0, sizeof(*dip)); // 分配空间 dip-&gt;type = type; log_write(bp); brelse(bp); return iget(dev, inum); &#125; brelse(bp); &#125; panic(\"ialloc: no inodes\");&#125; 锁inode ilock锁定给定的inode。如有必要，从磁盘读取inode。 1234567891011121314151617181920212223242526voidilock(struct inode *ip)&#123; struct buf *bp; struct dinode *dip; if(ip == 0 || ip-&gt;ref &lt; 1) panic(\"ilock\"); acquiresleep(&amp;ip-&gt;lock); // 请求inode锁 if(ip-&gt;valid == 0)&#123; // inode内容未从磁盘读取 bp = bread(ip-&gt;dev, IBLOCK(ip-&gt;inum, sb)); dip = (struct dinode*)bp-&gt;data + ip-&gt;inum%IPB; ip-&gt;type = dip-&gt;type; ip-&gt;major = dip-&gt;major; ip-&gt;minor = dip-&gt;minor; ip-&gt;nlink = dip-&gt;nlink; ip-&gt;size = dip-&gt;size; memmove(ip-&gt;addrs, dip-&gt;addrs, sizeof(ip-&gt;addrs)); brelse(bp); ip-&gt;valid = 1; if(ip-&gt;type == 0) // inode未被分配，出错，引发恐慌 panic(\"ilock: no type\"); &#125;&#125; 释放引用 iput释放对内存中的某一inode的引用，即引用数减一。对iput（）的所有调用必须在会话内，因为它可能释放inode。 123456789101112131415161718192021222324voidiput(struct inode *ip)&#123; acquiresleep(&amp;ip-&gt;lock); // 请求inode锁 // 如果这是最后一个引用，则可以回收inode缓存条目。 if(ip-&gt;valid &amp;&amp; ip-&gt;nlink == 0)&#123; acquire(&amp;icache.lock); int r = ip-&gt;ref; release(&amp;icache.lock); if(r == 1)&#123; // inode has no links and no other references: truncate and free. // 如果那是最后一个引用并且inode没有连接，释放磁盘上的inode（及其内容）。 itrunc(ip); ip-&gt;type = 0; iupdate(ip); ip-&gt;valid = 0; &#125; &#125; releasesleep(&amp;ip-&gt;lock); // 释放 inode 锁 acquire(&amp;icache.lock); ip-&gt;ref--; // 引用计数减一 release(&amp;icache.lock);&#125; 其他函数 readsb 读超级块 bzero 将块内容清零 iupdate 将修改后的内存中inode复制到磁盘；必须在每次更改ip-&gt; xxx字段后调用；它存在于磁盘上，因为i-node缓存是直写式的；调用者必须持有i节点锁。 iunlock 对指定inode解锁 iunlockput iunlock和iput的结合。由于两种常常一起使用，故整合。 bmap 返回inode中第n个块的磁盘块地址，如果没有这样的块，bmap会分配一个。 stati 从inode复制属性信息。 readi 从inode读数据，调用者必须持有ip-&gt; lock。 writei 给inode写入数据，调用者必须持有ip-&gt; lock。 其中readi和writei均要求给定的偏移和读出的量不超出文件大小。 目录层数据结构目录的i节点的类型是T_DIR,.目录本身是以文件的方式存储到磁盘上的，它的数据是一系列的目录条目。 1234struct dirent &#123; ushort inum; // i节点号 char name[DIRSIZ]; // 目录名&#125;; 函数详细注释位于fs.c。 dirlookup 查找目录中指定名字的条目 dirlink 会写入一个新的目录条目到某一目录下 路径函数 namex 查找并返回inode以获取路径名。如果parent！= 0，则返回父项的inode并复制最终项。路径元素到名称，必须有DIRSIZ字节的空间。该函数必须在会话内部调用，因为它调用iput（）。 1234567891011121314151617181920212223242526272829303132333435static struct inode*namex(char *path, int nameiparent, char *name)&#123; struct inode *ip, *next; if(*path == '/') // 路径以反斜杠开始，则解析从根目录开始 ip = iget(ROOTDEV, ROOTINO); else // 其他情况下则从当前目录开始 ip = idup(myproc()-&gt;cwd); while((path = skipelem(path, name)) != 0)&#123; // 考虑路径中的每一个部分 ilock(ip); // 确保ip-&gt;type从磁盘中加载出来 if(ip-&gt;type != T_DIR)&#123; // 不是目录，查找失败 iunlockput(ip); return 0; &#125; // 最后一个路径元素，循环提前结束 if(nameiparent &amp;&amp; *path == '\\0')&#123; // Stop one level early. iunlock(ip); return ip; &#125; if((next = dirlookup(ip, name, 0)) == 0)&#123; // 寻找路径元素失败，查找失败 iunlockput(ip); return 0; &#125; iunlockput(ip); ip = next; &#125; if(nameiparent)&#123; iput(ip); return 0; &#125; return ip;&#125; skipelem 将路径中的下一个路径元素复制到名称中，返回指向复制后的元素的指针。 namei 解析path并返回对应的inode。 nameiparent 返回上级目录的i节点并且把最后一个元素拷贝到name中。 函数的详细内容位于fs.c 文件描述符层123456789struct file &#123; enum &#123; FD_NONE, FD_PIPE, FD_INODE &#125; type; // 文件分为管道文件和普通文件等，FD_NONE表示文件未使用 int ref; // reference count 引用计数 char readable; // 可读 char writable; // 可写 struct pipe *pipe; // 管道 struct inode *ip; // 指向i节点 uint off;&#125;; xv6中每个进程都有自己的打开文件表。每个打开文件均由上面的结构体表示，它是一个对i节点或者管道和文件偏移的封装。每次调用open都会创建一个新的file结构体。 如果多个进程相互独立地打开了同一个文件，不同的实例将拥有不同的I/O偏移。而且同一个file结构体可以在一个进程的文件表中多次出现，同时也可以在多个进程的文件表中出现。对每一个打开的文件都有一个引用计数，一个文件可以被打开用于读、写或者二者。 系统中所有的打开文件都存在于一个全局的文件表ftable中。 函数该层的函数位于file.c，详细注释见代码文件。 filealloc 分配文件，扫描整个文件表寻找没有被引用的文件并返回一个新的引用。 filedup 重复引用文件，增加引用计数。 fileclose 释放对文件引用的函数，减少引用计数，当一个文件的引用计数变为0的时候，根据文件类型的不同,释放掉当前的管道或者i节点。 fileread 读文件，实现对文件的read操作 filewrite 写文件，实现对文件的write操作。 filestat 获取文件的元信息，实现对文件的stat操作（只允许作用在inode）。 系统调用暂无内容。 文件系统中xv6可改进之处cache 使用的替换策略为LRU，算法较为简单。 链表的使用虽然实现简单，但查找效率低，时间复杂度高。若能使用哈希表等实现查找可提高效率。 目录查找目录查找为线性查找，在目录数量较多的情况下耗时巨大。若能使用树等结构，便能大大减小时间复杂度。 大小固定文件系统的大小在xv6中是不改变的，固定在一个磁盘设备上。这一点对于个人PC影响不大，但在需要存储大量文件或超大文件的情况下，便有些捉襟见肘。","categories":[],"tags":[{"name":"学习","slug":"学习","permalink":"http://yoursite.com/tags/学习/"}]},{"title":"建站日志","slug":"建站日志","date":"2019-07-26T06:00:02.000Z","updated":"2019-08-06T11:15:35.856Z","comments":true,"path":"2019/07/26/建站日志/","link":"","permalink":"http://yoursite.com/2019/07/26/建站日志/","excerpt":"主题Next一开始选用的是Yilia,但由于Yilia开发使用的webpack版本较老，定制时易踩坑，故改用Next。本文根据官方文档整理，并根据自己喜好加入了一些第三方插件和修改。所有修改将会逐步给出，Next的配置完整说明可参照官方文档。","text":"主题Next一开始选用的是Yilia,但由于Yilia开发使用的webpack版本较老，定制时易踩坑，故改用Next。本文根据官方文档整理，并根据自己喜好加入了一些第三方插件和修改。所有修改将会逐步给出，Next的配置完整说明可参照官方文档。 基本配置下载12cd 博客根目录git clone https://github.com/iissnan/hexo-theme-next themes/next 启用打开根目录中的 _config.yml 文件,更改 theme 为 next 。 1234# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: next 选择Scheme打开 theme/next 中的 _config.yml 文件，选择 Muse 。 12345# Schemesscheme: Muse#scheme: Mist#scheme: Pisces#scheme: Gemini 切换语言打开根目录中的 _config.yml 文件,设置 language 为 zh-Hans 。 自定义主页文章阴影效果打开 themes/next/source/css/_custom/custom.styl ,增加 12345678// 主页文章添加阴影效果 .post &#123; margin-top: 60px; margin-bottom: 60px; padding: 25px; -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5); -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5); &#125; 修改标签打开 themes/next/layout/_macro/post.swig ，搜索 rel=&quot;tag&quot;&gt;#，将 # 换成 &lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt; 。 动态背景打开 theme/next/layout/_layout.swig ，在 &lt; /body&gt;之前添加代码 123&#123;% if theme.canvas_nest %&#125;&lt;script type=\"text/javascript\" src=\"//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js\"&gt;&lt;/script&gt;&#123;% endif %&#125; 打开 theme/next 中的 _config.yml 文件,将 canvas_next 置为 true 。 1canvas_nest: true 看板狗安装 12npm install hexo-helper-live2d --savenpm install live2d-widget-model-wanko 打开根目录中的 _config.yml 文件,增加以下代码。其中对 display 部分做了修改，以适应网页布局。 1234567891011121314151617181920212223242526272829# Live2D## https://github.com/EYHN/hexo-helper-live2dlive2d: enable: true # enable: false scriptFrom: local # 默认 pluginRootPath: live2dw/ # 插件在站点上的根目录(相对路径) pluginJsPath: lib/ # 脚本文件相对与插件根目录路径 pluginModelPath: assets/ # 模型文件相对与插件根目录路径 # scriptFrom: jsdelivr # jsdelivr CDN # scriptFrom: unpkg # unpkg CDN # scriptFrom: https://cdn.jsdelivr.net/npm/live2d-widget@3.x/lib/L2Dwidget.min.js # 你的自定义 url tagMode: false # 标签模式, 是否仅替换 live2d tag标签而非插入到所有页面中 debug: false # 调试, 是否在控制台输出日志 model: use: live2d-widget-model-wanko # npm-module package name # use: wanko # 博客根目录/live2d_models/ 下的目录名 # use: ./wives/wanko # 相对于博客根目录的路径 # use: https://cdn.jsdelivr.net/npm/live2d-widget-model-wanko@1.0.5/assets/wanko.model.json # 你的自定义 url display: position: right width: 200 height: 400 # 水平位置 hOffset: 40 # 垂直位置 vOffset: -80 mobile: show: true # 手机中是否展示 Github Corners打开Github Corners,复制代码并粘贴代码到 themes/next/layout/_layout.swig 文件中(放在 &lt;div class=&quot;headband&quot;&gt;&lt;/div&gt; 的下面)，并把 href 改为正确的github地址。 由于比较喜欢这个小家伙一直出现，故更改代码中的 position: absolute 为 position: fixed 。 123&lt;div class=\"headband\"&gt;&lt;/div&gt;&lt;a href=\"https://github.com/RootReturn0\" class=\"github-corner\" aria-label=\"View source on GitHub\"&gt;&lt;svg width=\"80\" height=\"80\" viewBox=\"0 0 250 250\" style=\"fill:#151513; color:#fff; position: fixed; top: 0; border: 0; right: 0;\" aria-hidden=\"true\"&gt;&lt;path d=\"M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z\"&gt;&lt;/path&gt;&lt;path d=\"M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2\" fill=\"currentColor\" style=\"transform-origin: 130px 106px;\" class=\"octo-arm\"&gt;&lt;/path&gt;&lt;path d=\"M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z\" fill=\"currentColor\" class=\"octo-body\"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;&lt;style&gt;.github-corner:hover .octo-arm&#123;animation:octocat-wave 560ms ease-in-out&#125;@keyframes octocat-wave&#123;0%,100%&#123;transform:rotate(0)&#125;20%,60%&#123;transform:rotate(-25deg)&#125;40%,80%&#123;transform:rotate(10deg)&#125;&#125;@media (max-width:500px)&#123;.github-corner:hover .octo-arm&#123;animation:none&#125;.github-corner .octo-arm&#123;animation:octocat-wave 560ms ease-in-out&#125;&#125;&lt;/style&gt; RSS12cd 博客根目录npm install hexo-generator-feed --save 打开根目录中的 _config.yml 文件,添加 123# Extensions## Plugins: http://hexo.io/plugins/plugins: hexo-generate-feed 打开 theme/next 中的 _config.yml 文件,在 rss 后添加 /atom.xml 1234# Set rss to false to disable feed link.# Leave rss as empty to use site's feed link.# Set rss to specific value if you have burned your feed already.rss: /atom.xml 加密有时写博客并不希望让所有人看到，故加入了加密功能。Hexo是一个静态博客，自己写一个js进行加密虽不困难，但样式实在不可恭维。这里采用大神做出的hexo-blog-encrypt进行加密。 安装12cd 博客根目录npm install hexo-blog-encrypt --save 配置根本配置打开根目录中的 _config.yml 文件,添加 12encrypt: enable: true 自定义配置然后在blog的头部添加上对应的字段，如password, abstract, message。 1234567---title: 文章加密date: 2019-08-06 19:00:02password: 你的密码abstract: 显示在目录页或首页的内容简介。message: 此处为输入密码时的提示内容。--- 全局配置希望修改默认的提示和摘要内容时，你可以添加如下配置在根目录中的 _config.yml 文件中。 1234encrypt: enable: true default_abstract: 这是一篇加密文章，内容可能是xxx default_message: 输入密码，查看文章。","categories":[],"tags":[{"name":"日志","slug":"日志","permalink":"http://yoursite.com/tags/日志/"}]},{"title":"hello world","slug":"hello-world","date":"2019-07-25T12:43:01.000Z","updated":"2019-07-26T14:28:49.946Z","comments":true,"path":"2019/07/25/hello-world/","link":"","permalink":"http://yoursite.com/2019/07/25/hello-world/","excerpt":"","text":"12345#include &lt;iostream&gt;int main()&#123; std::cout&lt;&lt;\"Hello world!\"&lt;&lt;std::endl;&#125; 12def hello() print('Hello world!')","categories":[],"tags":[]},{"title":"ILY","slug":"ILY","date":"2019-07-25T11:26:00.000Z","updated":"2019-07-25T11:58:50.263Z","comments":true,"path":"2019/07/25/ILY/","link":"","permalink":"http://yoursite.com/2019/07/25/ILY/","excerpt":"","text":"I am here. A ghost.","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]}]}